[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.3.1","content-config-digest","1acac442e7cd5450","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://cjhosken.github.io\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","posts",["Map",11,12,40,41,80,81,104,105,133,134,157,158,187,188,207,208],"breeze",{"id":11,"data":13,"body":20,"filePath":21,"digest":22,"rendered":23,"legacyId":39},{"title":14,"date":15,"role":16,"img":17,"excerpt":18,"type":19},"Breeze","2022-08-13","Solo Project","breeze_render_engine.png","A 3D application with a simple built-in raytracer written in C++ with Qt and OpenGL.","other","![Cover](/images/content/breeze/breeze_render_engine.png)\n\n## Overview\n\nBreeze Render Engine is a c++ program that can create and render 3-dimensional scenes. Users have the ability to add, edit, and move objects to create their own pieces of art. Breeze Render Engine is my first C++ project, and has taken me around 8 months part time to complete.\n\nBuilt off the Ray Tracing in One Weekend tutorial series, Breeze Render Engine was written with C++, OpenGL, and Qt. The purpose of Breeze was to help me understand C++ Desktop app development and how most modern day DCC's operate.\n\nYou can download and try the application from https://github.com/cjhosken/breeze_render_engine. \n\n\n## Pre-existing work (AP Physics Engine)\n\n![AP Physics Engine](/images/content/breeze/apengine.png)\n\nBefore Breeze was written, I had previously developed another 3D application in Java FX. This was a joint project for my AP Physics 1 and AP Computer Science A classes in High School (6th form). \nThe engine was designed to simulate collisions with conservation of momentum. \n\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/breeze/ap_engine_demo.mp4\" type=\"video/mp4\">\n\u003C/video>\n\nAlthough the Physics engine was planned to contain more concepts from AP Physics 1, many features had to be removed due to time concerns. This means that only Forces and Momentum were able to be implemented, and the only objects in the scenes were cubes. I was disatisfied with the result and wanted to explore more in the realm of desktop app development.\n\n## Breeze Development\n\n![Objects](/images/content/breeze/objs.png)\n\nBreeze was written in C++ alongside OpenGL and Qt. I found that [Ray Tracing in one Weekend](https://raytracing.github.io/books/RayTracingInOneWeekend.html) and [Learn OpenGL](https://learnopengl.com/) especially useful in the development of Breeze and would recommend those resources for anyone else looking to learn DCC development.\n\nI wanted to especially focus on the professional look of the application and tried to make it as minimal as possible. This involved lots of reasearching into Material Design, in which Google has numerous useful resources. I'm especially proud of figuring out a .obj file importer.\n\nThe video below shows Breeze in use.\n\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/breeze/breeze_demo.mp4\" type=\"video/mp4\">\n\u003C/video>\n\n*Written August 13, 2022 by Christopher Hosken*","src/content/posts/breeze.md","2910b9a2dca95413",{"html":24,"metadata":25},"\u003Cp>\u003Cimg src=\"/images/content/breeze/breeze_render_engine.png\" alt=\"Cover\">\u003C/p>\n\u003Ch2 id=\"overview\">Overview\u003C/h2>\n\u003Cp>Breeze Render Engine is a c++ program that can create and render 3-dimensional scenes. Users have the ability to add, edit, and move objects to create their own pieces of art. Breeze Render Engine is my first C++ project, and has taken me around 8 months part time to complete.\u003C/p>\n\u003Cp>Built off the Ray Tracing in One Weekend tutorial series, Breeze Render Engine was written with C++, OpenGL, and Qt. The purpose of Breeze was to help me understand C++ Desktop app development and how most modern day DCC’s operate.\u003C/p>\n\u003Cp>You can download and try the application from \u003Ca href=\"https://github.com/cjhosken/breeze_render_engine\">https://github.com/cjhosken/breeze_render_engine\u003C/a>.\u003C/p>\n\u003Ch2 id=\"pre-existing-work-ap-physics-engine\">Pre-existing work (AP Physics Engine)\u003C/h2>\n\u003Cp>\u003Cimg src=\"/images/content/breeze/apengine.png\" alt=\"AP Physics Engine\">\u003C/p>\n\u003Cp>Before Breeze was written, I had previously developed another 3D application in Java FX. This was a joint project for my AP Physics 1 and AP Computer Science A classes in High School (6th form).\nThe engine was designed to simulate collisions with conservation of momentum.\u003C/p>\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/breeze/ap_engine_demo.mp4\" type=\"video/mp4\">\n\u003C/video>\n\u003Cp>Although the Physics engine was planned to contain more concepts from AP Physics 1, many features had to be removed due to time concerns. This means that only Forces and Momentum were able to be implemented, and the only objects in the scenes were cubes. I was disatisfied with the result and wanted to explore more in the realm of desktop app development.\u003C/p>\n\u003Ch2 id=\"breeze-development\">Breeze Development\u003C/h2>\n\u003Cp>\u003Cimg src=\"/images/content/breeze/objs.png\" alt=\"Objects\">\u003C/p>\n\u003Cp>Breeze was written in C++ alongside OpenGL and Qt. I found that \u003Ca href=\"https://raytracing.github.io/books/RayTracingInOneWeekend.html\">Ray Tracing in one Weekend\u003C/a> and \u003Ca href=\"https://learnopengl.com/\">Learn OpenGL\u003C/a> especially useful in the development of Breeze and would recommend those resources for anyone else looking to learn DCC development.\u003C/p>\n\u003Cp>I wanted to especially focus on the professional look of the application and tried to make it as minimal as possible. This involved lots of reasearching into Material Design, in which Google has numerous useful resources. I’m especially proud of figuring out a .obj file importer.\u003C/p>\n\u003Cp>The video below shows Breeze in use.\u003C/p>\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/breeze/breeze_demo.mp4\" type=\"video/mp4\">\n\u003C/video>\n\u003Cp>\u003Cem>Written August 13, 2022 by Christopher Hosken\u003C/em>\u003C/p>",{"headings":26,"imagePaths":37,"frontmatter":38},[27,31,34],{"depth":28,"slug":29,"text":30},2,"overview","Overview",{"depth":28,"slug":32,"text":33},"pre-existing-work-ap-physics-engine","Pre-existing work (AP Physics Engine)",{"depth":28,"slug":35,"text":36},"breeze-development","Breeze Development",[],{"title":14,"type":19,"date":15,"role":16,"excerpt":18,"img":17},"breeze.md","creator",{"id":40,"data":42,"body":48,"filePath":49,"digest":50,"rendered":51,"legacyId":79},{"title":43,"date":44,"role":16,"img":45,"excerpt":46,"type":47},"The Creator Case Study","2023-12-14","cover.jpg","A case study on CG head replacements, inspired by an Industrial Light and Magic talk on The Creator.","project","# Exploring VFX: CG Head Replacement\n\nInspired by ILM's latest work on The Creator, The National Centre for Computer Animation – Bournemouth University student, Christopher Hosken, embarked on the challenge of exdcuting a CG head replacement, driven by the creative spark ignited by their cutting-edge techniques. In this article, Christopher takes a deeper dive into his processes, challenges and successes with this project.\n\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/creator/TheCreatorStudy_mp4.mp4\" type=\"video/mp4\">\n\u003C/video>\n\n## About The Project\nEvery year, Bournemouth University hosts the [BFX Festival]() in which artists and studios come to give talks and connect with students. One of the talks was from [*Industrial Light and Magic*]() on [*The Creator*](), and as I had recently seen *The Creator* and was blown away by the visuals, I decided to attend.\n\nThe talk completely shifted my views on VFX. The way ILM described their work made it sound like it was a walk in the park, especially the CG head replacements, which the film has a LOT of. I came out of the talk thinking, *\"If ILM makes it sound so easy, why don't I try a CG head replacement shot myself?\"*\n\nI specifically wanted to try and integrate a robot head into a shot without any other assets. No information about the set, No on-set HDRIs, just the clip. While it may not be true, I believed that for a film like *The Creator*, this is what most of the artists were dealing with.\n\n\n## Plate Preparation\n\nI started by finding footage on Action VFX that would match the same theme as *The Creator*. Since the film is about a war between humanity and AI, I wanted something that felt war-related and sci-fi.\n\nI ended up choosing a short clip of a solider being punched by a guard. I liked the shot because I could showcase the CG head integration well. I also decided to integrate a CG hand because I thought *\"If I'm going to do this, why not go the whole way.\"*.\n\n![Raw](/images/content/creator/raw_still.jpg) \u003Cbr>\n\u003Csmall> (Footage from ActionVFX) \u003C/small>\n\nOnce I had my clip, I began tracking the shot and rotoscoping individual elements. Due to the defocused background, I had to grade and sharpen the footage to get a stable track. Once I had the track, I started to reconstruct the backplate.\n\nThe backplate took the most amount of time in this project. It was especially difficult to build behind the subjects head as there wasn't much data. I ended up doing a combination of roto-masks, roto-paints, and 3D cards. The reason for 3D cards was because of how the actor's arm goes across the entire shot. It would mess up any mask I made, and since I had a pretty good track, I used cards to re-build the back walls.\n\nAlthough some regions of the backplate weren’t completely accurate, I knew that the robot head and the general action of the scene would distract the audience and stop them from noticing.\n\n![Raw](/images/content/creator/cleanplate_still.jpg)\n\nI then used [KeenTools]() to track the actors head. I had never used KeenTools before, but I heard ILM mention it multiple times in their talk. It took a couple attempts to get a decent track, but once I started to figure it out I understood why ILM used it. Some frames needed to be manually tracked, but it was a lot more efficient than doing manual point tracks.\n\nOnce complete, I exported the head track to [Blender]() and began working on the 3D elements.\n\n## 3D Elements\n\nFor modelling, I built the head and hand using [Adrian Rutkowski’s Kitbashing library](). Asset creation wasn't the primary focus of this project, so I wanted to design the models as quickly as possible. I started with a base mesh and then iterated on top of it by duplicating, scaling, and editing other kit bash elements.\n\nFor texturing, I used the premade [Substance 3D]() materials and changed the colours of different parts. I also added small decals to make the character a bit more interesting. The colours I chose were supposed to be similar to that of police colours. I felt that making the robot seem like it was part of the police would kick off the audience's imagination at to what might be happening.\n\n\n![Hand](/images/content/creator/hand_turntable.jpg) ![Head](/images/content/creator/head_turntable.jpg)\n\nOnce I finished the models, I threw them into a lookdev environment to see how they would look under realistic lighting. I wasn't too worried about the brightness and saturation of the colours as I planned on colour matching them in [Nuke](), I just wanted to make sure that materials were reflecting as they should.\n\nI then the KeenTools track and attached the robot head to it. I wasn't able to figure out how to export my KeenTools head with correct scale, so I had to a bit of constraint magic to place the CG head at the right distance. I also had to do a bit of repositioning in some frames so that the track looked more consistent.\n\nFor the hand, I track it by eye into the shot, and then animated it to close into a fist. I did this by quickly rigging the hand with Rigify and then animating it with animation controls. The hardest part with animation was getting it to match the footage correctly, there were moments where the head or hand would slide around in place, and dialing that in took a lot of time.\n\n![Hand](/images/content/creator/viewport.jpg)\u003Cbr>\n\u003Csmall>(I also used a jacket model from csheffield on Sketchfab to cast shadows where the neck would meet the jacket in the shot.)\u003C/small>\n\nOnce animation was complete, I lit the scene, rendered it out, and then dived back into Nuke.\n\n## Integration\n\nIntegrating the 3D elements into the shot also took some time. In the rendering stage I create different light passes that I could combine in comp. The different passes made it a lot easier for me to match the lighting to the shot. Without it, I would have had to re-render the scene multiple times.\n\nFor the grade, I was lucky enough to attend Victor Perez's compositing masterclass at the BFX Festival. The class taught me the basics of the Nuke grade node and how to integrate CG elements into shots. Without learning from him, I would have struggled a lot more on matching the grade between the elements.\n\nOnce the grain and chromatic aberration were added, I exported the shot into DaVinci Resolve and added a cinematic grade with SFX and music.\n\n![Hand](/images/content/creator/nuke_script.jpg) \n\n## Conclusion\n\nOverall I’m quite happy with the final shot. I was able to learn a lot about compositing, especially with doing backplate reconstruction and using KeenTools.\n\nIf I was to continue working on the shot, I would probably focus more on my lighting as well as refine my roto-masks. There a couple area's of the shot in which shadows aren't realistic and parts of the backplate morph and disappear. However, I feel that for a quick study on The Creator, it looks great.\n\nYou can watch the full breakdown below:\n\n\u003Ciframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BRdFg-8wEYE?si=AB6Ppzpw4KFl1f03\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen>\u003C/iframe>\n\n## Lessons Learned\n\nMore recently I've discovered that I learn a lot more doing the long projects than the short ones, and this project was no exception. I am used to working on projects and then move onto something new as soon as I get stuck, but I've found that pushing through the discomfort of things not working has made me a much better artist over the past couple of months.\n\nIn terms of actual technical knowledge, I've found that doing everything step-by-step is whole lot easier than trying to do it in parallel. Don't try and integrate your CG while you're still doing your backplate. Make each part look perfect on it's own, and then bring it all together at the end.\n\nI'm definitely going to use KeenTools in my future projects, I found that not only does it do heads, but anything! It's a very cool tool and I'm excited to use it more.\n\n*Written Feb 6, 2024 by Christopher Hosken*","src/content/posts/creator.md","8f7cdda460237608",{"html":52,"metadata":53},"\u003Ch1 id=\"exploring-vfx-cg-head-replacement\">Exploring VFX: CG Head Replacement\u003C/h1>\n\u003Cp>Inspired by ILM’s latest work on The Creator, The National Centre for Computer Animation – Bournemouth University student, Christopher Hosken, embarked on the challenge of exdcuting a CG head replacement, driven by the creative spark ignited by their cutting-edge techniques. In this article, Christopher takes a deeper dive into his processes, challenges and successes with this project.\u003C/p>\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/creator/TheCreatorStudy_mp4.mp4\" type=\"video/mp4\">\n\u003C/video>\n\u003Ch2 id=\"about-the-project\">About The Project\u003C/h2>\n\u003Cp>Every year, Bournemouth University hosts the \u003Ca href=\"\">BFX Festival\u003C/a> in which artists and studios come to give talks and connect with students. One of the talks was from \u003Ca href=\"\">\u003Cem>Industrial Light and Magic\u003C/em>\u003C/a> on \u003Ca href=\"\">\u003Cem>The Creator\u003C/em>\u003C/a>, and as I had recently seen \u003Cem>The Creator\u003C/em> and was blown away by the visuals, I decided to attend.\u003C/p>\n\u003Cp>The talk completely shifted my views on VFX. The way ILM described their work made it sound like it was a walk in the park, especially the CG head replacements, which the film has a LOT of. I came out of the talk thinking, \u003Cem>“If ILM makes it sound so easy, why don’t I try a CG head replacement shot myself?”\u003C/em>\u003C/p>\n\u003Cp>I specifically wanted to try and integrate a robot head into a shot without any other assets. No information about the set, No on-set HDRIs, just the clip. While it may not be true, I believed that for a film like \u003Cem>The Creator\u003C/em>, this is what most of the artists were dealing with.\u003C/p>\n\u003Ch2 id=\"plate-preparation\">Plate Preparation\u003C/h2>\n\u003Cp>I started by finding footage on Action VFX that would match the same theme as \u003Cem>The Creator\u003C/em>. Since the film is about a war between humanity and AI, I wanted something that felt war-related and sci-fi.\u003C/p>\n\u003Cp>I ended up choosing a short clip of a solider being punched by a guard. I liked the shot because I could showcase the CG head integration well. I also decided to integrate a CG hand because I thought \u003Cem>“If I’m going to do this, why not go the whole way.”\u003C/em>.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/creator/raw_still.jpg\" alt=\"Raw\"> \u003Cbr>\n\u003Csmall> (Footage from ActionVFX) \u003C/small>\u003C/p>\n\u003Cp>Once I had my clip, I began tracking the shot and rotoscoping individual elements. Due to the defocused background, I had to grade and sharpen the footage to get a stable track. Once I had the track, I started to reconstruct the backplate.\u003C/p>\n\u003Cp>The backplate took the most amount of time in this project. It was especially difficult to build behind the subjects head as there wasn’t much data. I ended up doing a combination of roto-masks, roto-paints, and 3D cards. The reason for 3D cards was because of how the actor’s arm goes across the entire shot. It would mess up any mask I made, and since I had a pretty good track, I used cards to re-build the back walls.\u003C/p>\n\u003Cp>Although some regions of the backplate weren’t completely accurate, I knew that the robot head and the general action of the scene would distract the audience and stop them from noticing.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/creator/cleanplate_still.jpg\" alt=\"Raw\">\u003C/p>\n\u003Cp>I then used \u003Ca href=\"\">KeenTools\u003C/a> to track the actors head. I had never used KeenTools before, but I heard ILM mention it multiple times in their talk. It took a couple attempts to get a decent track, but once I started to figure it out I understood why ILM used it. Some frames needed to be manually tracked, but it was a lot more efficient than doing manual point tracks.\u003C/p>\n\u003Cp>Once complete, I exported the head track to \u003Ca href=\"\">Blender\u003C/a> and began working on the 3D elements.\u003C/p>\n\u003Ch2 id=\"3d-elements\">3D Elements\u003C/h2>\n\u003Cp>For modelling, I built the head and hand using \u003Ca href=\"\">Adrian Rutkowski’s Kitbashing library\u003C/a>. Asset creation wasn’t the primary focus of this project, so I wanted to design the models as quickly as possible. I started with a base mesh and then iterated on top of it by duplicating, scaling, and editing other kit bash elements.\u003C/p>\n\u003Cp>For texturing, I used the premade \u003Ca href=\"\">Substance 3D\u003C/a> materials and changed the colours of different parts. I also added small decals to make the character a bit more interesting. The colours I chose were supposed to be similar to that of police colours. I felt that making the robot seem like it was part of the police would kick off the audience’s imagination at to what might be happening.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/creator/hand_turntable.jpg\" alt=\"Hand\"> \u003Cimg src=\"/images/content/creator/head_turntable.jpg\" alt=\"Head\">\u003C/p>\n\u003Cp>Once I finished the models, I threw them into a lookdev environment to see how they would look under realistic lighting. I wasn’t too worried about the brightness and saturation of the colours as I planned on colour matching them in \u003Ca href=\"\">Nuke\u003C/a>, I just wanted to make sure that materials were reflecting as they should.\u003C/p>\n\u003Cp>I then the KeenTools track and attached the robot head to it. I wasn’t able to figure out how to export my KeenTools head with correct scale, so I had to a bit of constraint magic to place the CG head at the right distance. I also had to do a bit of repositioning in some frames so that the track looked more consistent.\u003C/p>\n\u003Cp>For the hand, I track it by eye into the shot, and then animated it to close into a fist. I did this by quickly rigging the hand with Rigify and then animating it with animation controls. The hardest part with animation was getting it to match the footage correctly, there were moments where the head or hand would slide around in place, and dialing that in took a lot of time.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/creator/viewport.jpg\" alt=\"Hand\">\u003Cbr>\n\u003Csmall>(I also used a jacket model from csheffield on Sketchfab to cast shadows where the neck would meet the jacket in the shot.)\u003C/small>\u003C/p>\n\u003Cp>Once animation was complete, I lit the scene, rendered it out, and then dived back into Nuke.\u003C/p>\n\u003Ch2 id=\"integration\">Integration\u003C/h2>\n\u003Cp>Integrating the 3D elements into the shot also took some time. In the rendering stage I create different light passes that I could combine in comp. The different passes made it a lot easier for me to match the lighting to the shot. Without it, I would have had to re-render the scene multiple times.\u003C/p>\n\u003Cp>For the grade, I was lucky enough to attend Victor Perez’s compositing masterclass at the BFX Festival. The class taught me the basics of the Nuke grade node and how to integrate CG elements into shots. Without learning from him, I would have struggled a lot more on matching the grade between the elements.\u003C/p>\n\u003Cp>Once the grain and chromatic aberration were added, I exported the shot into DaVinci Resolve and added a cinematic grade with SFX and music.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/creator/nuke_script.jpg\" alt=\"Hand\">\u003C/p>\n\u003Ch2 id=\"conclusion\">Conclusion\u003C/h2>\n\u003Cp>Overall I’m quite happy with the final shot. I was able to learn a lot about compositing, especially with doing backplate reconstruction and using KeenTools.\u003C/p>\n\u003Cp>If I was to continue working on the shot, I would probably focus more on my lighting as well as refine my roto-masks. There a couple area’s of the shot in which shadows aren’t realistic and parts of the backplate morph and disappear. However, I feel that for a quick study on The Creator, it looks great.\u003C/p>\n\u003Cp>You can watch the full breakdown below:\u003C/p>\n\u003Ciframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BRdFg-8wEYE?si=AB6Ppzpw4KFl1f03\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen>\u003C/iframe>\n\u003Ch2 id=\"lessons-learned\">Lessons Learned\u003C/h2>\n\u003Cp>More recently I’ve discovered that I learn a lot more doing the long projects than the short ones, and this project was no exception. I am used to working on projects and then move onto something new as soon as I get stuck, but I’ve found that pushing through the discomfort of things not working has made me a much better artist over the past couple of months.\u003C/p>\n\u003Cp>In terms of actual technical knowledge, I’ve found that doing everything step-by-step is whole lot easier than trying to do it in parallel. Don’t try and integrate your CG while you’re still doing your backplate. Make each part look perfect on it’s own, and then bring it all together at the end.\u003C/p>\n\u003Cp>I’m definitely going to use KeenTools in my future projects, I found that not only does it do heads, but anything! It’s a very cool tool and I’m excited to use it more.\u003C/p>\n\u003Cp>\u003Cem>Written Feb 6, 2024 by Christopher Hosken\u003C/em>\u003C/p>",{"headings":54,"imagePaths":77,"frontmatter":78},[55,59,62,65,68,71,74],{"depth":56,"slug":57,"text":58},1,"exploring-vfx-cg-head-replacement","Exploring VFX: CG Head Replacement",{"depth":28,"slug":60,"text":61},"about-the-project","About The Project",{"depth":28,"slug":63,"text":64},"plate-preparation","Plate Preparation",{"depth":28,"slug":66,"text":67},"3d-elements","3D Elements",{"depth":28,"slug":69,"text":70},"integration","Integration",{"depth":28,"slug":72,"text":73},"conclusion","Conclusion",{"depth":28,"slug":75,"text":76},"lessons-learned","Lessons Learned",[],{"title":43,"date":44,"role":16,"excerpt":46,"img":45,"type":47},"creator.md","hdtemplate",{"id":80,"data":82,"body":87,"filePath":88,"digest":89,"rendered":90,"legacyId":103},{"title":83,"date":84,"role":16,"img":85,"excerpt":86,"type":19},"HdTemplate","2025-01-01","cover.png","A simple Hydra Delegate raytracer written for UsdView and Houdini Solaris.","![UsdView](/images/content/hdtemplate/cover.png)\n\n## Overview\n\nIn order to understand how USD is making moves in the world of software development I decided to experiment with making a Hydra Delegate raytracer. The delegate works in multiple DCCs and the Github repository can be found at https://github.com/cjhosken/hdTemplateRenderer.\n\n## UsdView\n\nThe delegate was originally built for UsdView in C++. Using a BVH structure and a hard-coded distant light, the USD Kitchen Scene could be rendered. \n\nThe render shown below is the HdTemplateRenderer after ~ 10 minutes. The basic sphere scene was rendered in ~ 30 seconds.\n\n![UsdView](/images/content/hdtemplate/cover.png)\n![UsdView](/images/content/hdtemplate/simple.png)\n\nA render of the USD Kitchen Scene in Usdview using HdTemplateRenderer after ~ 10 minutes.\n\n## Houdini\n\nUsing the Houdini USD build, the delegate was expanded for use in Houdini Solaris. The delegate has 3 AOVs, Beauty, Normal, Depth.\n\n![Houdini Beauty](/images/content/hdtemplate/hou_beauty.png)\n![Houdini Depth](/images/content/hdtemplate/hou_depth.png)\n![Houdini Normal](/images/content/hdtemplate/hou_normal.png)\n\n*Written Jan 1, 2025 by Christopher Hosken*","src/content/posts/hdtemplate.md","1a80f5593414789e",{"html":91,"metadata":92},"\u003Cp>\u003Cimg src=\"/images/content/hdtemplate/cover.png\" alt=\"UsdView\">\u003C/p>\n\u003Ch2 id=\"overview\">Overview\u003C/h2>\n\u003Cp>In order to understand how USD is making moves in the world of software development I decided to experiment with making a Hydra Delegate raytracer. The delegate works in multiple DCCs and the Github repository can be found at \u003Ca href=\"https://github.com/cjhosken/hdTemplateRenderer\">https://github.com/cjhosken/hdTemplateRenderer\u003C/a>.\u003C/p>\n\u003Ch2 id=\"usdview\">UsdView\u003C/h2>\n\u003Cp>The delegate was originally built for UsdView in C++. Using a BVH structure and a hard-coded distant light, the USD Kitchen Scene could be rendered.\u003C/p>\n\u003Cp>The render shown below is the HdTemplateRenderer after ~ 10 minutes. The basic sphere scene was rendered in ~ 30 seconds.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/hdtemplate/cover.png\" alt=\"UsdView\">\n\u003Cimg src=\"/images/content/hdtemplate/simple.png\" alt=\"UsdView\">\u003C/p>\n\u003Cp>A render of the USD Kitchen Scene in Usdview using HdTemplateRenderer after ~ 10 minutes.\u003C/p>\n\u003Ch2 id=\"houdini\">Houdini\u003C/h2>\n\u003Cp>Using the Houdini USD build, the delegate was expanded for use in Houdini Solaris. The delegate has 3 AOVs, Beauty, Normal, Depth.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/hdtemplate/hou_beauty.png\" alt=\"Houdini Beauty\">\n\u003Cimg src=\"/images/content/hdtemplate/hou_depth.png\" alt=\"Houdini Depth\">\n\u003Cimg src=\"/images/content/hdtemplate/hou_normal.png\" alt=\"Houdini Normal\">\u003C/p>\n\u003Cp>\u003Cem>Written Jan 1, 2025 by Christopher Hosken\u003C/em>\u003C/p>",{"headings":93,"imagePaths":101,"frontmatter":102},[94,95,98],{"depth":28,"slug":29,"text":30},{"depth":28,"slug":96,"text":97},"usdview","UsdView",{"depth":28,"slug":99,"text":100},"houdini","Houdini",[],{"title":83,"date":84,"role":16,"excerpt":86,"img":85,"type":19},"hdtemplate.md","heman",{"id":104,"data":106,"body":111,"filePath":112,"digest":113,"rendered":114,"legacyId":132},{"title":107,"date":108,"role":109,"img":85,"excerpt":110,"type":47},"Heman","2025-01-17","University Assignment","A stylzed hero asset made in ZBrush, Maya, and Houdini.","![Cover](/images/content/heman/cover.png)\n\n## Modelling\n\nAs part of our Modelling and Tetxturing Assignment at Bournemouth University, we were tasked with making a stylzed hero asset based on a given concept. I decided to choose the Heman concept by Michael McCabe.\n\n![Original Reference](/images/content/heman/heman_doodle.jpg)\n\nWe began by blocking out our character in ZBrush; starting the basic shapes, then the muscles, then the finer details. The hardsurface assets were then modelling in Maya.\n\n![ZBrush](/images/content/heman/heman_zbrush.png)\n\n## Rigging\n\nThe rig was created from scratch in Maya. I hadn't done FK/IK switching before and wanted to give that a go.\n\n![Rigging](/images/content/heman/heman_rig.png)\n\n\n## Houdini & Lookdev\nThe asset was then textured in Substance Painter and brought into Houdini for groom. Heman was rendered in a custom Houdini Lookdev environment that I designed.\n\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/heman/heman_turntable.mp4\" type=\"video/mp4\">\n\u003C/video>\n\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/heman/heman_wireframe_turntable.mp4\" type=\"video/mp4\">\n\u003C/video>\n\n\n## USD Pipeline\n\nContinuing on from the [Jupiter Steam Train](/portfolio/jupiter) I built Heman as a USD asset. This is following a new USD Pipeline workflow that I have developed for future projects.\n\n![USD Pipe](/images/content/heman/usd_pipe.png)\n\nThe pipeline worked extremely well for completing a full rounded-character.\n\n\n*Written Jan 17, 2025 by Christopher Hosken*","src/content/posts/heman.md","1520d7fe0869701b",{"html":115,"metadata":116},"\u003Cp>\u003Cimg src=\"/images/content/heman/cover.png\" alt=\"Cover\">\u003C/p>\n\u003Ch2 id=\"modelling\">Modelling\u003C/h2>\n\u003Cp>As part of our Modelling and Tetxturing Assignment at Bournemouth University, we were tasked with making a stylzed hero asset based on a given concept. I decided to choose the Heman concept by Michael McCabe.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/heman/heman_doodle.jpg\" alt=\"Original Reference\">\u003C/p>\n\u003Cp>We began by blocking out our character in ZBrush; starting the basic shapes, then the muscles, then the finer details. The hardsurface assets were then modelling in Maya.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/heman/heman_zbrush.png\" alt=\"ZBrush\">\u003C/p>\n\u003Ch2 id=\"rigging\">Rigging\u003C/h2>\n\u003Cp>The rig was created from scratch in Maya. I hadn’t done FK/IK switching before and wanted to give that a go.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/heman/heman_rig.png\" alt=\"Rigging\">\u003C/p>\n\u003Ch2 id=\"houdini--lookdev\">Houdini &#x26; Lookdev\u003C/h2>\n\u003Cp>The asset was then textured in Substance Painter and brought into Houdini for groom. Heman was rendered in a custom Houdini Lookdev environment that I designed.\u003C/p>\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/heman/heman_turntable.mp4\" type=\"video/mp4\">\n\u003C/video>\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/heman/heman_wireframe_turntable.mp4\" type=\"video/mp4\">\n\u003C/video>\n\u003Ch2 id=\"usd-pipeline\">USD Pipeline\u003C/h2>\n\u003Cp>Continuing on from the \u003Ca href=\"/portfolio/jupiter\">Jupiter Steam Train\u003C/a> I built Heman as a USD asset. This is following a new USD Pipeline workflow that I have developed for future projects.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/heman/usd_pipe.png\" alt=\"USD Pipe\">\u003C/p>\n\u003Cp>The pipeline worked extremely well for completing a full rounded-character.\u003C/p>\n\u003Cp>\u003Cem>Written Jan 17, 2025 by Christopher Hosken\u003C/em>\u003C/p>",{"headings":117,"imagePaths":130,"frontmatter":131},[118,121,124,127],{"depth":28,"slug":119,"text":120},"modelling","Modelling",{"depth":28,"slug":122,"text":123},"rigging","Rigging",{"depth":28,"slug":125,"text":126},"houdini--lookdev","Houdini & Lookdev",{"depth":28,"slug":128,"text":129},"usd-pipeline","USD Pipeline",[],{"title":107,"date":108,"role":109,"excerpt":110,"img":85,"type":47},"heman.md","jupiter",{"id":133,"data":135,"body":139,"filePath":140,"digest":141,"rendered":142,"legacyId":156},{"title":136,"date":137,"role":16,"img":45,"excerpt":138,"type":47},"Jupiter","2024-10-21","A case study on USD asset creation.","![References](/images/content/jupiter/cover.jpg)\n\n## Introduction\n\nUSD has become the \"Buzz Word\" for the animation and visual effects industry. And I felt (as an aspiring Generalist TD), that learning how USD works would be crucial for landing a job outside of university. \n\nIn an effort to explore the capabilities of USD, I decided to create Jupiter, an American steam train from the late 1800s. I've always wanted to model a steam train, and I love the wild-west style of the Jupiter. I spent a total of 2 and half months working on this project, and this is by far my favourite asset I've worked on yet.\n\n![References](/images/content/jupiter/references.png)\n\nI began the project by looking for references online, I used PureRef to bundle them together so I could easily look at them when needed.\n\n## Modelling\n\nTo explore the benefits of USD's cross DCC abilities, I decided to model inside of Blender. I'm a huge fan of Blender's modelling tools, and once I transferred the asset into Maya, I polished the model and created the UVs. This was my \"payload\" file for my USD asset. It contained all the geometry data, including UVs for shading.\n\n![Modelling](/images/content/jupiter/modelling.png)\n\n![UVs](/images/content/jupiter/uvs.png)\n\n\u003Ciframe src=\"https://www.fab.com/dope/5bf19a46-e3ad-4489-add9-fe32ffcdf76e\" title=\"Model preview file (5bf19a46-e3ad-4489-add9-fe32ffcdf76e)\" class=\"_g148NR_ AKPfHZv1\" allowfullscreen=\"\">\u003C/iframe>\n\nAbove is the final model of Jupiter. The hardest part of the asset was getting all the intricate details inside the train, as there weren't many references images of those areas.\n\n\n## Lookdev\n\nOnce the payload was finished, I began working on shading and lookdev. I was able to convert Albin Merle's free Blender lookdev environment into USD, which I could open and use inside of Maya and Houdini.\n\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/jupiter/vibrant_turntable.mp4\" type=\"video/mp4\">\n\u003C/video>\n\n\nWith Substance painter, I working on getting the nice wear and tear of an old train. I was also able to make a shading variant look called \"dull\", which looks cleaner and more toy-like.\n\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/jupiter/dull_turntable.mp4\" type=\"video/mp4\">\n\u003C/video>\n\nI did my rendering inside of Maya using Arnold, however the asset also works with Houdini's Karma.\n\n## Conclusion\n\nOverall, I'm very happy with this asset. If I had more time to work on it, I would look into rigging and animating it, as well as combining it with FX in Houdini. This project has helped me gain better understanding of USD, and how it works in the animation and VFX pipeline, and I can't wait to use it in more of my projects. \n\n*Written Oct 21, 2024 by Christopher Hosken*","src/content/posts/jupiter.md","e702e23443523ff5",{"html":143,"metadata":144},"\u003Cp>\u003Cimg src=\"/images/content/jupiter/cover.jpg\" alt=\"References\">\u003C/p>\n\u003Ch2 id=\"introduction\">Introduction\u003C/h2>\n\u003Cp>USD has become the “Buzz Word” for the animation and visual effects industry. And I felt (as an aspiring Generalist TD), that learning how USD works would be crucial for landing a job outside of university.\u003C/p>\n\u003Cp>In an effort to explore the capabilities of USD, I decided to create Jupiter, an American steam train from the late 1800s. I’ve always wanted to model a steam train, and I love the wild-west style of the Jupiter. I spent a total of 2 and half months working on this project, and this is by far my favourite asset I’ve worked on yet.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/jupiter/references.png\" alt=\"References\">\u003C/p>\n\u003Cp>I began the project by looking for references online, I used PureRef to bundle them together so I could easily look at them when needed.\u003C/p>\n\u003Ch2 id=\"modelling\">Modelling\u003C/h2>\n\u003Cp>To explore the benefits of USD’s cross DCC abilities, I decided to model inside of Blender. I’m a huge fan of Blender’s modelling tools, and once I transferred the asset into Maya, I polished the model and created the UVs. This was my “payload” file for my USD asset. It contained all the geometry data, including UVs for shading.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/jupiter/modelling.png\" alt=\"Modelling\">\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/jupiter/uvs.png\" alt=\"UVs\">\u003C/p>\n\u003Ciframe src=\"https://www.fab.com/dope/5bf19a46-e3ad-4489-add9-fe32ffcdf76e\" title=\"Model preview file (5bf19a46-e3ad-4489-add9-fe32ffcdf76e)\" class=\"_g148NR_ AKPfHZv1\" allowfullscreen>\u003C/iframe>\n\u003Cp>Above is the final model of Jupiter. The hardest part of the asset was getting all the intricate details inside the train, as there weren’t many references images of those areas.\u003C/p>\n\u003Ch2 id=\"lookdev\">Lookdev\u003C/h2>\n\u003Cp>Once the payload was finished, I began working on shading and lookdev. I was able to convert Albin Merle’s free Blender lookdev environment into USD, which I could open and use inside of Maya and Houdini.\u003C/p>\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/jupiter/vibrant_turntable.mp4\" type=\"video/mp4\">\n\u003C/video>\n\u003Cp>With Substance painter, I working on getting the nice wear and tear of an old train. I was also able to make a shading variant look called “dull”, which looks cleaner and more toy-like.\u003C/p>\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/jupiter/dull_turntable.mp4\" type=\"video/mp4\">\n\u003C/video>\n\u003Cp>I did my rendering inside of Maya using Arnold, however the asset also works with Houdini’s Karma.\u003C/p>\n\u003Ch2 id=\"conclusion\">Conclusion\u003C/h2>\n\u003Cp>Overall, I’m very happy with this asset. If I had more time to work on it, I would look into rigging and animating it, as well as combining it with FX in Houdini. This project has helped me gain better understanding of USD, and how it works in the animation and VFX pipeline, and I can’t wait to use it in more of my projects.\u003C/p>\n\u003Cp>\u003Cem>Written Oct 21, 2024 by Christopher Hosken\u003C/em>\u003C/p>",{"headings":145,"imagePaths":154,"frontmatter":155},[146,149,150,153],{"depth":28,"slug":147,"text":148},"introduction","Introduction",{"depth":28,"slug":119,"text":120},{"depth":28,"slug":151,"text":152},"lookdev","Lookdev",{"depth":28,"slug":72,"text":73},[],{"title":136,"date":137,"role":16,"excerpt":138,"img":45,"type":47},"jupiter.md","painter",{"id":157,"data":159,"body":164,"filePath":165,"digest":166,"rendered":167,"legacyId":186},{"title":160,"date":161,"role":109,"img":162,"excerpt":163,"type":19},"PAINter","2024-01-10","desert_wip.png","An MSPaint-like application written in C++ and SDL2.","![PAINter](/images/content/painter/desert_wip.png)\n\n## Overview\n\nFor my Programming Principles class at Bournemouth University, we had to write a C++/SDL2 application. I chose to make an MSPaint-like program. You can see the manual and report below.\n\n![PAINter](/images/content/painter/desert.png)\n\nI found that using an old paint software like this extremely frustrating to use. Hence the name, ***PAIN***ter.\n\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/painter/demo.mp4\" type=\"video/mp4\">\n\u003C/video>\n\nThe project repository can be found at https://github.com/cjhosken/PAINter.\n\n## PAINter Report\n**This report is a summary of the report written for the Programming Principles class assignment at Bournemouth University. If you wish to read the full report you can download it [here](/images/content/painter/painter_report.pdf).**\n\n### Introduction\n\nThis project aimed to create a Raster Graphics Editor / Paint Program in C++ using SDL. As I enjoy UI design and making desktop applications, I felt that PAINter would be a good challenge for developing my programming skills. To get inspiration for the project, I looked at programs such as MSPaint, Photoshop, and Krita. Once I got to grips with those programs, I created a flow chart diagram in Miro to see how PAINter would work.\n\n![Flow Chart](/images/content/painter/flow.png)\n\n### User Interface\n\nThe user interface is fairly standard with slider and button controls. I jumped into Figma to make a simple mockup of what I felt would work for the application. Whilst implementing the interfance, I decided to go with an object-oriented structure so that I could easily change buttons, sliders, and other UI elements. This way of designing a UI is very scalable as I could (theoretically) have multiple types of windows, buttons, and sliders.\n\n![Figma UI](/images/content/painter/real_ui.png)\n\nA common trend in modern UIs is to have bevelled rectangle shapes. Because SDL2 has no built-in UI, I had to write the bevelling myself. This was done by creating 3 smaller rectangles, and ¼ circles to place on the corners of the main rectangle. I used a “radius” detector that would draw a normal rectangle if the radius was 0. I could then re-call this function for the 3 small rectangles.\n\n### Loading, Creating, Saving\nI aimed for loading, creating, and saving to be done within the user interface. However, I decided to use command arguments instead due to text-displaying issues. Users could load a pre-existing image and save it in any format.\n\n\n### Conclusion\nOverall I am quite happy with this project. However, If I were to continue working on it, these are the things that I would address next.\n- Faster line drawing algorithm\n- Reusable window / Gui classes with individual event management\n- Buttons for loading and creating images\n\n\n*Written January 10, 2024 by Christopher Hosken*","src/content/posts/painter.md","028ad9aac97f8c32",{"html":168,"metadata":169},"\u003Cp>\u003Cimg src=\"/images/content/painter/desert_wip.png\" alt=\"PAINter\">\u003C/p>\n\u003Ch2 id=\"overview\">Overview\u003C/h2>\n\u003Cp>For my Programming Principles class at Bournemouth University, we had to write a C++/SDL2 application. I chose to make an MSPaint-like program. You can see the manual and report below.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/painter/desert.png\" alt=\"PAINter\">\u003C/p>\n\u003Cp>I found that using an old paint software like this extremely frustrating to use. Hence the name, \u003Cem>\u003Cstrong>PAIN\u003C/strong>\u003C/em>ter.\u003C/p>\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/painter/demo.mp4\" type=\"video/mp4\">\n\u003C/video>\n\u003Cp>The project repository can be found at \u003Ca href=\"https://github.com/cjhosken/PAINter\">https://github.com/cjhosken/PAINter\u003C/a>.\u003C/p>\n\u003Ch2 id=\"painter-report\">PAINter Report\u003C/h2>\n\u003Cp>\u003Cstrong>This report is a summary of the report written for the Programming Principles class assignment at Bournemouth University. If you wish to read the full report you can download it \u003Ca href=\"/images/content/painter/painter_report.pdf\">here\u003C/a>.\u003C/strong>\u003C/p>\n\u003Ch3 id=\"introduction\">Introduction\u003C/h3>\n\u003Cp>This project aimed to create a Raster Graphics Editor / Paint Program in C++ using SDL. As I enjoy UI design and making desktop applications, I felt that PAINter would be a good challenge for developing my programming skills. To get inspiration for the project, I looked at programs such as MSPaint, Photoshop, and Krita. Once I got to grips with those programs, I created a flow chart diagram in Miro to see how PAINter would work.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/painter/flow.png\" alt=\"Flow Chart\">\u003C/p>\n\u003Ch3 id=\"user-interface\">User Interface\u003C/h3>\n\u003Cp>The user interface is fairly standard with slider and button controls. I jumped into Figma to make a simple mockup of what I felt would work for the application. Whilst implementing the interfance, I decided to go with an object-oriented structure so that I could easily change buttons, sliders, and other UI elements. This way of designing a UI is very scalable as I could (theoretically) have multiple types of windows, buttons, and sliders.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/painter/real_ui.png\" alt=\"Figma UI\">\u003C/p>\n\u003Cp>A common trend in modern UIs is to have bevelled rectangle shapes. Because SDL2 has no built-in UI, I had to write the bevelling myself. This was done by creating 3 smaller rectangles, and ¼ circles to place on the corners of the main rectangle. I used a “radius” detector that would draw a normal rectangle if the radius was 0. I could then re-call this function for the 3 small rectangles.\u003C/p>\n\u003Ch3 id=\"loading-creating-saving\">Loading, Creating, Saving\u003C/h3>\n\u003Cp>I aimed for loading, creating, and saving to be done within the user interface. However, I decided to use command arguments instead due to text-displaying issues. Users could load a pre-existing image and save it in any format.\u003C/p>\n\u003Ch3 id=\"conclusion\">Conclusion\u003C/h3>\n\u003Cp>Overall I am quite happy with this project. However, If I were to continue working on it, these are the things that I would address next.\u003C/p>\n\u003Cul>\n\u003Cli>Faster line drawing algorithm\u003C/li>\n\u003Cli>Reusable window / Gui classes with individual event management\u003C/li>\n\u003Cli>Buttons for loading and creating images\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cem>Written January 10, 2024 by Christopher Hosken\u003C/em>\u003C/p>",{"headings":170,"imagePaths":184,"frontmatter":185},[171,172,175,177,180,183],{"depth":28,"slug":29,"text":30},{"depth":28,"slug":173,"text":174},"painter-report","PAINter Report",{"depth":176,"slug":147,"text":148},3,{"depth":176,"slug":178,"text":179},"user-interface","User Interface",{"depth":176,"slug":181,"text":182},"loading-creating-saving","Loading, Creating, Saving",{"depth":176,"slug":72,"text":73},[],{"title":160,"date":161,"role":109,"excerpt":163,"img":162,"type":19},"painter.md","rhino",{"id":187,"data":189,"body":193,"filePath":194,"digest":195,"rendered":196,"legacyId":206},{"title":190,"date":191,"role":16,"img":85,"excerpt":192,"type":47},"Rhino FX","2024-12-24","Experimenting with MPM and Solaris environment layouts.","![Cover](/images/content/rhino/cover.png)\n\n## Introduction\n\nRhino FX was an exploriation into the MPM tools in Houdini, as well as how to build environments using Houdini Solaris. I used Quixel assets for the envionment, and found an animation of a Rhino online. The FX was done by me in Houdini.\n\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/rhino/rhino_comp.mp4\" type=\"video/mp4\">\n\u003C/video>\n\n## Breakdown\n\n\nA viewport animation of the environment. Mostly made up of Quixel Megascans, I re-purposed an old USD Quixel asset generator to quickly make instancable USD assets. The trees were made using Houdini's tree generation tools. I had enough variants to populate the scene without repetition.\n\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/rhino/viewport_v001.mp4\" type=\"video/mp4\">\n\u003C/video>\n\nThe mud simulation was done using Houdini's new MPM simulation tool. I combined it with a particle fluid surface to create a mud look. The wetmap on the Rhino is a simple SOP solver that uses attribute transfers to remember collisions with the fluid.\n\n*Written December 12, 2024 by Christopher Hosken*","src/content/posts/rhino.md","48d5e94d9a6e9ccf",{"html":197,"metadata":198},"\u003Cp>\u003Cimg src=\"/images/content/rhino/cover.png\" alt=\"Cover\">\u003C/p>\n\u003Ch2 id=\"introduction\">Introduction\u003C/h2>\n\u003Cp>Rhino FX was an exploriation into the MPM tools in Houdini, as well as how to build environments using Houdini Solaris. I used Quixel assets for the envionment, and found an animation of a Rhino online. The FX was done by me in Houdini.\u003C/p>\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/rhino/rhino_comp.mp4\" type=\"video/mp4\">\n\u003C/video>\n\u003Ch2 id=\"breakdown\">Breakdown\u003C/h2>\n\u003Cp>A viewport animation of the environment. Mostly made up of Quixel Megascans, I re-purposed an old USD Quixel asset generator to quickly make instancable USD assets. The trees were made using Houdini’s tree generation tools. I had enough variants to populate the scene without repetition.\u003C/p>\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/rhino/viewport_v001.mp4\" type=\"video/mp4\">\n\u003C/video>\n\u003Cp>The mud simulation was done using Houdini’s new MPM simulation tool. I combined it with a particle fluid surface to create a mud look. The wetmap on the Rhino is a simple SOP solver that uses attribute transfers to remember collisions with the fluid.\u003C/p>\n\u003Cp>\u003Cem>Written December 12, 2024 by Christopher Hosken\u003C/em>\u003C/p>",{"headings":199,"imagePaths":204,"frontmatter":205},[200,201],{"depth":28,"slug":147,"text":148},{"depth":28,"slug":202,"text":203},"breakdown","Breakdown",[],{"title":190,"date":191,"role":16,"excerpt":192,"img":85,"type":47},"rhino.md","mfs",{"id":207,"data":209,"body":214,"filePath":215,"digest":216,"rendered":217,"legacyId":250},{"title":210,"date":211,"role":109,"img":212,"excerpt":213,"type":19},"Maya Fluid Simulator","2024-05-10","MayaFluidSimulator.PNG","An PIC/FLIP particle simulator in Maya.","![Cover](/images/content/mfs/MayaFluidSimulator.PNG)\n\n## Overview\n\nPart of my Technical Arts Production unit at Bournemouth University required us to make a Maya tool with Python. I decided to challenge myself by looking into fluid simulators. \n\n*Maya Fluid Simulator *is a PIC/FLIP tool that allows you to simulate particle fluids.\n\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/mfs/MFS_tutorial.mp4\" this.type=\"video/mp4\">\n\u003C/video>\n\nMore results can be seen at the bottom of this article.\n\n## Maya Fluid Simulator Report\n**This report is a summary of the report created for the Technical Arts Production unit at Bournemouth University. If you wish to read the full report you can download it [here](/images/content/mfs/mfs_report.pdf).**\n\n### Introduction\n\n*Maya Fluid Simulator* is a PIC/FLIP tool that allows you to simulate particle fluids. Therefore it relies on the Navier Stokes equations.\n\n\u003Cimg src=\"/images/content/mfs/navier.png\" style=\"max-width:600px; align-self: center; margin: 2em;\">\n\nThere are numerous ways to implement the Navier Stokes equations into a fluid simulator, aside from SPH (Smoothed Particle Hydrodynamics), two of the most popular methods are PIC (Particle in Cell), and FLIP (Fluid Implicit this.particles). Both methods combine Lagrangian simulation with Euler simulation. \n\nThe Lagrangian simulation method relies on particle movement to describe fluid motion. This is often more realistic as fluid is (fundamentally) made of this.particles. However, this method can be extremely computationally expensive when calculating divergence and solving the this.pressure gradient. The Euler method combats this computational time by storing velocity, density, and other attributes within a grid. This is often the preferred method for gas-based simulations such as fire and smoke, as it is much faster to calculate. However, the particle-like nature of the fluid is lost.\n\nPIC and FLIP combine the particle-like nature of lagrangian simulations with the speed of Eulerian. The method is explained below.\n\n- Particle velocities are transferred to the grid and density is calculated. The velocity grid is then copied\n- A timestep is calculated\n- Boundaries are enforced\n- Fluid is made divergence-free\n- Velocity is transferred to the this.particles using the old and new velocity grids\n- Particle collisions are handled\n\n\u003Cbr>\n\n### Particle to Grid and Grid to Particle\n\nOne of the most important parts of the algorithm was transferring velocity between the this.particles and the grid. This was done through trilinear interpolation on a staggered grid. A staggered grid offsets the position of certain attributes so that they can be interpolated and averaged correctly. \n\n\u003Cimg src=\"/images/content/mfs/p2g.png\" style=\"max-width:400px; align-self: center; margin: 2em;\">\n\nthis.pressure was stored in an array the size of the domain resolution, whilst velocities were stored in arrays with a size +1 on their corresponding index.\n```py\n\n    self.velocity_u = np.zeros((self.resolution[0]+1, self.resolution[1], self.resolution[2]), dtype=\"float64\")\n    self.velocity_v = np.zeros((self.resolution[0], self.resolution[1]+1, self.resolution[2]), dtype=\"float64\")\n    self.velocity_w = np.zeros((self.resolution[0], self.resolution[1], self.resolution[2]+1), dtype=\"float64\")\n    self.pressure = np.zeros((self.resolution[0], self.resolution[1], self.resolution[2]), dtype=\"float64\")\n    \n```\n\n\u003Cimg src=\"/images/content/mfs/trillinear.png\" style=\"max-width:400px; align-self: center; margin: 2em;\">\n\nThe weights were calculated by finding the particle offset in cell space (dx =  x - int(x)), and then multiplying by an in_bounds() check. This means any velocity values outside the domain (which don't exist), don't contribute to the trilinear interpolation.\n```py \n\nc000 = (1 - dx) * (1 - dy) * (1 - dz) * self.in_bounds(i, j, k, resolution[0], resolution[1], resolution[2])\n...\n\n```\n\nThe first line is how velocity would be transferred from a particle to the grid. The second line is the inverse; grid to particle.\n```py\n\nself.velocity_v[min(i, self.resolution[0] - 1)][min(j, self.resolution[1])][min(k, self.resolution[2] - 1)] += p.velocity[1] * c000\n\nvelocity_v += self.velocity_v[min(i, self.resolution[0]-1)][min(j, self.resolution[1] )][min(k, self.resolution[2] -1)] * c000\n\n```\n\nTo keep the simulation stable, velocities must be normalised by the sum of their weights. An average this.pressure value must also be calculated for the first frame of the simulation. This is very important for making sure the divergence calculation is correct.\n\n### Finding dt\nWith Lagrangian simulations, a timestep can remain constant as the this.particles aren't \ntraversing any grids. In PIC and FLIP, however, the this.particles cannot skip over cells, as doing \nso may destabilise the simulation. Therefore, a timestep needs to be calculated. This concept \nis the CFL (Courant–Friedrichs–Lewy) condition. The technique implemented below was \ninspired by Robert Bridson. \n\n```py\n\n    def calc_dt(self, particles, timescale, external_force):\n        max_speed = 0\n\n        for particle in particles:\n            speed = np.linalg.norm(particle.velocity)\n            max_speed = max(max_speed, speed)\n\n        max_dist = np.linalg.norm(self.cell_size) * np.linalg.norm(external_force)\n\n        if (max_speed \u003C= 0):\n            max_speed = 1\n\n        return min(timescale, max(timescale * max_dist / max_speed, 1))\n\n```\n\nThe function finds the fastest particle and calculates a timestep so that the particle would move only 1 grid cell. A timescale variable is used so users can set the visual speed of the simulation.\n\n\n### Enforcing Boundaries and Solving Divergence\n\nEnforcing boundaries is extremely simple. Using the Neumann Boundary condition, all boundary velocity components that point out of the domain are set to 0. The loss of velocity is then corrected when the divergence is solved. \n\nThere are numerous ways to make the fluid velocity field divergence-free, but the easiest to implement is the Gauss-Seidel method (a modern version of the Jacobi method). Divergence is calculated by finding the velocity difference in each cell, then a this.pressure force is subtracted.\n\nA border value is then calculated to spread the divergence evenly along each velocity component. \n\n\n### Particle Collisions\n\nTwo this.types of collisions need to be handled in the simulation: domain and particle. \nHandling domain collisions is relatively simple. Integrate the particle, then check if its \nposition is outside the domain. If so,  zero its velocity (across the axis), and set the particle \nposition to the boundary edge.\n\nAs the number of this.particles increases, the time needed to calculate particle collisions \nincreases dramatically. To combat this, Hash mapping was implemented. Hash mapping \nassigns close this.particles to the same array, heavily reducing the number of collision tests \nbetween this.particles.\n\n### PIC and FLIP\n\nAlthough PIC and FLIP follow (essentially) the same code structure. The way they \naffect particle velocity is slightly different. For PIC, velocity from the grid is directly \nassigned to the particle velocity. For FLIP, a velocity difference is calculated between the old \ngrid (particle to grid) and the grid after all the force and divergence calculations. The velocity \ndifference is then added to the particle velocity.\n\n![PIC and FLIP](/images/content/mfs/picflip.png)\n\nPIC is usually more viscous, and FLIP is usually more splashy. The purpose of the \nPIC/FLIP slider is so that users can choose how much viscosity they want the fluid to have. \nThis is also why the viscosity force was left out of the code.\n\n### Results\n\nBelow are some benchmark tests for *Maya Fluid Simulator*. Tests were run on Windows 10 Enterprise with an Intel i7-13700, 64GB RAM, and NVIDIA GeForce RTX 4080.\n\nThe Default Donut simulation had a particle count of 4800. A particle scale of 0.1 and a PIC/FLIP Mix of 0.6. It simulated 120 frames in 3 minutes 33 seconds.\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/mfs/MFS_DefaultDonut.mp4\" this.type=\"video/mp4\">\n\u003C/video>\n\nThe Dam Break simulation had a particle count of 15000. A particle scale of 0.1 and a PIC/FLIP Mix of 0.8. It simulated 120 frames in 9 minutes 20 seconds.\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/mfs/MFS_DamBreak.mp4\" this.type=\"video/mp4\">\n\u003C/video>\n\nThe Honey simulation had a particle count of 4800. A particle scale of 0.2 and a PIC/FLIP Mix of 0.0. It simulated 120 frames in 1 minute 8 seconds.\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/mfs/MFS_Honey.mp4\" this.type=\"video/mp4\">\n\u003C/video>\n\n### JS Simulator\n\nThis a simple 2D version of the simulator that was used for debugging the Maya python code.\n\u003Cbr> \u003C/br>\n***WARNING MAY SLOW DOWN DEVICE***\n\n\n\u003Cdiv width=\"100%\" style=\"display: flex; flex-direction: column;\">\n\u003Cbutton id=\"resetButton\" style=\"width:5em;height:2em;font-size:1em;margin:1em auto;justify-self:center;\"> Restart \u003C/button>\n\u003Ccanvas id=\"particleCanvas\" width=\"300\" height=\"300\" style=\"margin: 0 auto; justify-self: center;\">\u003C/canvas>\n\u003C/div>\n\n\u003Cscript>\n        const canvas = document.getElementById('particleCanvas');\n        const canvasWidth = canvas.width;  // Get canvas width\n        const canvasHeight = canvas.height; // Get canvas height\n        var CELL_COUNT = canvas.width/20;\n        var BOUNDS = [canvas.width, canvas.height]\n        var CELL_SIZE = [BOUNDS[0] / CELL_COUNT, BOUNDS[1] / CELL_COUNT]\n        var GRID_SIZE = canvas.width/10;\n        var OFFSET = [canvas.width/2, -canvas.height/2]\n        var PSCALE = canvas.width/100;\n        var EXTERNAL = [0, 98];\n        var AVERAGE = -1\n\n        function HSVtoRGB(h, s, v) {\n            let c = v * s;\n            let hp = (h / 60) % 6;\n            let x = c * (1 - Math.abs(hp % 2 - 1));\n            let rgb = [0, 0, 0];\n\n            if (0 \u003C= hp && hp \u003C 1) {\n                rgb = [c, x, 0];\n            } else if (1 \u003C= hp && hp \u003C 2) {\n                rgb = [x, c, 0];\n            } else if (2 \u003C= hp && hp \u003C 3) {\n                rgb = [0, c, x];\n            } else if (3 \u003C= hp && hp \u003C 4) {\n                rgb = [0, x, c];\n            } else if (4 \u003C= hp && hp \u003C 5) {\n                rgb = [x, 0, c];\n            } else if (5 \u003C= hp && hp \u003C 6) {\n                rgb = [c, 0, x];\n            }\n\n            let m = v - c;\n            rgb[0] += m;\n            rgb[1] += m;\n            rgb[2] += m;\n\n            // Scale RGB values to the range [0, 255]\n            return rgb.map(val => Math.round(val * 255));\n        }\n\n        class Particle {\n            constructor(x, y, radius) {\n                this.position = [x, y];\n                this.velocity = [-50.0, 500.0];\n                this.radius = radius;\n            }\n            draw(ctx) {\n                ctx.beginPath();\n                ctx.arc(this.position[0], this.position[1], this.radius, 0, Math.PI * 2);\n\n                var speed = Math.sqrt(this.velocity[0] * this.velocity[0] + this.velocity[1] * this.velocity[1])\n\n                speed = Math.sqrt(speed) / 6\n\n                let rgbColor = HSVtoRGB(200, Math.max(3 / speed, 0.01), Math.max(speed, 0.7));\n\n                ctx.fillStyle = `rgb(${rgbColor[0]}, ${rgbColor[1]}, ${rgbColor[2]})`;\n                ctx.strokeStyle = \"black\"\n                ctx.fill();\n                //this.ctx.stroke();\n            }\n        }\n\n        class Game {\n          constructor(){\n            this.canvas = document.getElementById('particleCanvas');\n            this.ctx = this.canvas.getContext('2d');\n\n            this.reset();\n\n            this.animate = this.animate.bind(this);\n          }\n\n          reset() {\n            this.particles = new Array(GRID_SIZE * GRID_SIZE).fill(null)\n            this.velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n            this.velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));\n\n            this.last_velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n            this.last_velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));\n\n            this.type = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n            this.pressure = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n\n            this.particleHashTable = {};\n\n            for (let o = 0; o \u003C GRID_SIZE; o++) {\n                for (let p = 0; p \u003C GRID_SIZE; p++) {\n                    const index = o * GRID_SIZE + p\n                    this.particles[index] = new Particle(\n                        (o + 0.5) * (PSCALE * 2) + OFFSET[0],\n                        (p + 0.5) * (PSCALE * 2) + OFFSET[1] + (PSCALE * 2 * GRID_SIZE),\n                        PSCALE\n                    );\n                }\n            }\n          }\n\n\n          update() {\n                this.clear()\n                var tscale = 0.05\n                let average = this.particle_to_grid()\n                if (AVERAGE == -1) {\n                    AVERAGE = average\n                } \n                let dt = this.calc_dt(tscale)\n                this.calc_forces(dt)\n                this.enforce_boundaries()\n                this.solve_divergence(AVERAGE)\n                this.particle_from_grid(dt)\n                this.handle_collisions_and_boundary(dt)\n\n            }\n\n          drawGrid() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n                if (true) {\n                    for (let i = 0; i \u003C CELL_COUNT; i += 1) {\n                        for (let j = 0; j \u003C CELL_COUNT; j += 1) {\n                            this.ctx.beginPath();\n                            this.ctx.strokeStyle = \"black\"\n                            this.ctx.strokeRect(i * CELL_SIZE[0], (j * CELL_SIZE[1]), CELL_SIZE[0], CELL_SIZE[1]);\n\n                            if (false) {\n                                if (this.type[i][j] == 1) {\n                                    this.ctx.fillStyle = \"blue\"\n                                    this.ctx.fillRect(i * CELL_SIZE[0],  (j * CELL_SIZE[1]), CELL_SIZE[0], CELL_SIZE[1]);\n                                }\n                                this.ctx.stroke();\n                            }\n\n                            if (false) {\n\n                            this.ctx.beginPath();\n                            this.ctx.arc((i + 0.5) * CELL_SIZE[0], ((j + 0.5) * CELL_SIZE[1]), Math.sqrt(this.pressure[i][j] * 10), 0, Math.PI * 2);\n                            this.ctx.fillStyle = \"green\"\n                            this.ctx.fill();\n                            this.ctx.stroke();\n                            }\n                        }\n                    }\n                \n                }\n\n                if (false) {\n\n                    for (let ux = 0; ux \u003C this.velocity_u.length; ux += 1) {\n                        for (let uy = this.velocity_u[0].length - 1; uy >= 0; uy -= 1) {\n                            this.ctx.beginPath();\n                            var v = Math.sqrt(Math.abs(this.velocity_u[ux][uy])) * 0.5\n                            this.ctx.arc((ux) * CELL_SIZE[0], ((uy + 0.5) * CELL_SIZE[1]), v, 0, Math.PI * 2);\n                            this.ctx.fillStyle = \"red\"\n                            this.ctx.fill();\n                            this.ctx.stroke();\n                        }\n                    }\n\n                    // Draw horizontal lines\n                    for (let vx = 0; vx \u003C this.velocity_v.length; vx += 1) {\n                        for (let vy = this.velocity_v[0].length - 1; vy >= 0; vy -= 1) {\n                            this.ctx.beginPath();\n                            var v = Math.sqrt(Math.abs(this.velocity_v[vx][vy])) * 0.5\n                            this.ctx.arc((vx + 0.5) * CELL_SIZE[0], ((vy) * CELL_SIZE[1]), v, 0, Math.PI * 2);\n                            this.ctx.fillStyle = \"green\"\n                            this.ctx.fill();\n                            this.ctx.stroke();\n                        }\n                    }\n                }\n\n                if (true) {\n                    this.particles.forEach(particle => {\n                        particle.draw(this.ctx);\n                    });\n                }\n\n            }\n\n          particle_to_grid() {\n                let weight_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n                let weight_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));\n\n                this.particles.forEach(particle => {\n                    let x = particle.position[0] / CELL_SIZE[0]\n                    let y = particle.position[1] / CELL_SIZE[1] - 0.5\n\n                    let i = Math.floor(x)\n                    let j = Math.floor(y)\n\n                    let dx = x - i\n                    let dy = y - j\n\n                    let b00 = this.in_bounds(i, j, this.velocity_u.length, this.velocity_u[0].length)\n                    let b10 = this.in_bounds(i + 1, j, this.velocity_u.length, this.velocity_u[0].length)\n                    let b01 = this.in_bounds(i, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n                    let b11 = this.in_bounds(i + 1, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n                    \n                    let w00 = (1 - dx) * (1 - dy) * b00\n                    let w10 = (dx) * (1 - dy) * b10\n                    let w01 = (1 - dx) * (dy) * b01\n                    let w11 = (dx) * (dy) * b11\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n                    this.last_velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] += w00 * particle.velocity[0]\n                    weight_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] += w00\n\n                    this.last_velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] += w10 * particle.velocity[0]\n                    weight_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] += w10\n\n                    this.last_velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] += w01 * particle.velocity[0]\n                    weight_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] += w01\n\n                    this.last_velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] += w11 * particle.velocity[0]\n                    weight_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] += w11\n\n\n                    x = particle.position[0] / CELL_SIZE[0] - 0.5\n                    y = particle.position[1] / CELL_SIZE[1]\n\n                    i = Math.floor(x)\n                    j = Math.floor(y)\n\n                    dx = x - i\n                    dy = y - j\n\n                    b00 = this.in_bounds(i, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b10 = this.in_bounds(i + 1, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b01 = this.in_bounds(i, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n                    b11 = this.in_bounds(i + 1, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n\n                    w00 = (1 - dx) * (1 - dy) * b00\n                    w10 = (dx) * (1 - dy) * b10\n                    w01 = (1 - dx) * (dy) * b01\n                    w11 = (dx) * (dy) * b11\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n                    this.last_velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] += w00 * particle.velocity[1]\n                    weight_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] += w00\n\n                    this.last_velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] += w10 * particle.velocity[1]\n                    weight_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] += w10\n\n                    this.last_velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] += w01 * particle.velocity[1]\n                    weight_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] += w01\n\n                    this.last_velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] += w11 * particle.velocity[1]\n                    weight_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] += w11\n\n                    x = particle.position[0] / CELL_SIZE[0] - 0.5\n                    y = particle.position[1] / CELL_SIZE[1] - 0.5\n\n                    i = Math.floor(x)\n                    j = Math.floor(y)\n\n                    dx = x - i\n                    dy = y - j\n\n                    b00 = this.in_bounds(i, j, this.pressure.length, this.pressure[0].length)\n                    b10 = this.in_bounds(i + 1, j, this.pressure.length, this.pressure[0].length)\n                    b01 = this.in_bounds(i, j + 1, this.pressure.length, this.pressure[0].length)\n                    b11 = this.in_bounds(i + 1, j + 1, this.pressure.length, this.pressure[0].length)\n\n                    w00 = (1 - dx) * (1 - dy) * b00\n                    w10 = (dx) * (1 - dy) * b10\n                    w01 = (1 - dx) * (dy) * b01\n                    w11 = (dx) * (dy) * b11\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n                    this.pressure[Math.min(i, this.pressure.length - 1)][Math.min(j, this.pressure[0].length - 1)] += w00\n\n                    this.pressure[Math.min(i + 1, this.pressure.length - 1)][Math.min(j, this.pressure[0].length - 1)] += w10\n\n\n                    this.pressure[Math.min(i, this.pressure.length - 1)][Math.min(j + 1, this.pressure[0].length - 1)] += w01\n\n                    this.pressure[Math.min(i + 1, this.pressure.length - 1)][Math.min(j + 1, this.pressure[0].length - 1)] += w11\n\n                    x = particle.position[0] / CELL_SIZE[0]\n                    y = particle.position[1] / CELL_SIZE[1]\n\n                    i = Math.max(Math.min(Math.floor(x), this.type.length - 1), 0)\n                    j = Math.max(Math.min(Math.floor(y), this.type[0].length - 1), 0)\n\n                    this.type[i][j] = 1\n                })\n\n                for (let ux = 0; ux \u003C this.velocity_u.length; ux++) {\n                    for (let uy = 0; uy \u003C this.velocity_u[0].length; uy++) {\n                        if (weight_u[ux][uy] > 0) {\n                            this.last_velocity_u[ux][uy] /= weight_u[ux][uy]\n                        }\n                    }\n                }\n\n                for (let vx = 0; vx \u003C this.velocity_v.length; vx++) {\n                    for (let vy = 0; vy \u003C this.velocity_v[0].length; vy++) {\n                        if (weight_v[vx][vy] > 2) {\n                            this.last_velocity_v[vx][vy] /= weight_v[vx][vy]\n                        }\n                    }\n                }\n\n\n                for (let ux = 0; ux \u003C this.velocity_u.length; ux++) {\n                    for (let uy = 0; uy \u003C this.velocity_u[0].length; uy++) {\n                        this.velocity_u[ux][uy] = this.last_velocity_u[ux][uy]\n                    }\n                }\n\n                for (let vx = 0; vx \u003C this.velocity_v.length; vx++) {\n                    for (let vy = 0; vy \u003C this.velocity_v[0].length; vy++) {\n                        this.velocity_v[vx][vy] = this.last_velocity_v[vx][vy]\n                    }\n                }\n\n                let num_fluid_cells = 0\n                let average_density = 0\n\n                for (let i = 0; i \u003C CELL_COUNT; i++) {\n                    for (let j = 0; j \u003C CELL_COUNT; j++) {\n                        if (this.type[i][j] == 1) {\n                            num_fluid_cells += 1\n                            average_density += this.pressure[i][j]\n                        }\n                    }\n                }\n\n                if (num_fluid_cells > 0) average_density /= num_fluid_cells\n\n                return average_density\n            }\n\n          in_bounds(i, j, lx, ly) {\n                return (\n                    0 \u003C= i \u003C lx &&\n                    0 \u003C= j \u003C ly\n                )\n            }\n\n          calc_dt(tscale) {\n                var max_speed = 0\n                this.particles.forEach(particle => {\n                    const speed_squared = particle.velocity[0] ** 2 + particle.velocity[1] ** 2\n                    max_speed = Math.max(speed_squared, max_speed)\n                })\n\n                max_speed = Math.sqrt(max_speed)\n\n                let max_dist = Math.sqrt((CELL_SIZE[0] ** 2 + CELL_SIZE[1] ** 2) * Math.sqrt(EXTERNAL[0] ** 2 + EXTERNAL[1] ** 2))\n\n                return Math.min(tscale, tscale * max_dist / max_speed, 1)\n            }\n\n          calc_forces(dt) {\n                let TOTAL_FORCE = [\n                    EXTERNAL[0],\n                    EXTERNAL[1]\n                ]\n\n                for (let ux = 0; ux \u003C this.velocity_u.length; ux++) {\n                    for (let uy = 0; uy \u003C this.velocity_u[0].length; uy++) {\n                        this.velocity_u[ux][uy] += EXTERNAL[0] * dt\n                    }\n                }\n\n                for (let vx = 0; vx \u003C this.velocity_v.length; vx++) {\n                    for (let vy = 0; vy \u003C this.velocity_v[0].length; vy++) {\n                        this.velocity_v[vx][vy] += EXTERNAL[1] * dt\n                    }\n                }\n            }\n\n          enforce_boundaries() {\n                for (let uy = 0; uy \u003C this.velocity_u[0].length; uy++) {\n                    if (this.velocity_u[0][uy] \u003C 0) this.velocity_u[0][uy] = 0\n                    if (this.velocity_u[this.velocity_u.length - 1][uy] > 0) this.velocity_u[this.velocity_u.length - 1][uy] = 0\n                }\n\n                for (let vx = 0; vx \u003C this.velocity_v.length; vx++) {\n                    if (this.velocity_v[vx][0] \u003C 0) this.velocity_v[vx][0] = 0\n                    if (this.velocity_v[vx][this.velocity_v[0].length - 1] > 0) this.velocity_v[vx][this.velocity_v[0].length - 1] = 0\n                }\n            }\n\n            // Function to compute the divergence of the velocity field\n          compute_divergence(vel_u, vel_v, CELL_COUNT, CELL_SIZE, average) {\n                let divergence = [];\n                for (let i = 0; i \u003C CELL_COUNT; i++) {\n                    divergence[i] = [];\n                    for (let j = 0; j \u003C CELL_COUNT; j++) {\n                        divergence[i][j] = 1.9 * (\n                            (vel_u[i + 1][j] - vel_u[i][j]) / (1 * CELL_SIZE[0]) +\n                            (vel_v[i][j + 1] - vel_v[i][j]) / (1 * CELL_SIZE[1])\n                        ) - 3 * (this.pressure[i][j] - average)\n                    }\n                }\n                return divergence;\n            }\n\n\n            // Function to solve divergence\n          solve_divergence(average) {\n                const tolerance = 0.1\n                const maxIterations = 1;\n\n                for (let n = 0; n \u003C maxIterations; n++) {\n                    const previousDivergence = this.compute_divergence(this.velocity_u, this.velocity_v, CELL_COUNT, CELL_SIZE, average);\n\n                    for (let i = 0; i \u003C CELL_COUNT; i++) {\n                        for (let j = 0; j \u003C CELL_COUNT; j++) {\n                            const borders = (\n                                this.in_bounds(i - 1, j, CELL_COUNT, CELL_COUNT) +\n                                this.in_bounds(i + 1, j, CELL_COUNT, CELL_COUNT) +\n                                this.in_bounds(i, j - 1, CELL_COUNT, CELL_COUNT) +\n                                this.in_bounds(i, j + 1, CELL_COUNT, CELL_COUNT)\n                            );\n\n                            const divergence = previousDivergence[i][j];\n                            this.velocity_u[i][j] += divergence * this.in_bounds(i - 1, j, CELL_COUNT, CELL_COUNT) / borders;\n                            this.velocity_u[i + 1][j] -= divergence * this.in_bounds(i + 1, j, CELL_COUNT, CELL_COUNT) / borders;\n                            this.velocity_v[i][j] += divergence * this.in_bounds(i, j - 1, CELL_COUNT, CELL_COUNT) / borders;\n                            this.velocity_v[i][j + 1] -= divergence * this.in_bounds(i, j + 1, CELL_COUNT, CELL_COUNT) / borders;\n                        }\n                    }\n\n                    const currentDivergence = this.compute_divergence(this.velocity_u, this.velocity_v, CELL_COUNT, CELL_SIZE, average);\n\n                    // Compute the change in divergence\n                    let divergenceChange = 0;\n                    for (let i = 0; i \u003C CELL_COUNT; i++) {\n                        for (let j = 0; j \u003C CELL_COUNT; j++) {\n                            divergenceChange += Math.abs(currentDivergence[i][j] - previousDivergence[i][j]);\n                        }\n                    }\n\n                    if (divergenceChange \u003C= tolerance) break;\n                }\n            }\n\n          particle_from_grid(dt) {\n                // Advect this.particles\n                this.particles.forEach(particle => {\n\n                    let integrated_position = [particle.position[0] + particle.velocity[0] * dt, particle.position[1]+ particle.velocity[1] * dt]\n\n                    let x = integrated_position[0] / CELL_SIZE[0]\n                    let y = integrated_position[1] / CELL_SIZE[1] - 0.5\n\n                    let i = Math.floor(x)\n                    let j = Math.floor(y)\n\n                    let dx = x - i\n                    let dy = y - j\n\n                    let b00 = this.in_bounds(i, j, this.velocity_u.length, this.velocity_u[0].length)\n                    let b10 = this.in_bounds(i + 1, j, this.velocity_u.length, this.velocity_u[0].length)\n                    let b01 = this.in_bounds(i, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n                    let b11 = this.in_bounds(i + 1, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n\n                    let w00 = (1 - dx) * (1 - dy) * (b00 && this.type[Math.min(i, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    let w10 = (dx) * (1 - dy) * (b10 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    let w01 = (1 - dx) * (dy) * (b01 && this.type[Math.min(i, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n                    let w11 = (dx) * (dy) * (b11 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n\n                    let total_weight = w00 + w10 + w01 + w11\n\n                    var vel_u = (\n                        this.velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] * w00 +\n                        this.velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] * w10 +\n                        this.velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] * w01 +\n                        this.velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] * w11\n                    )\n\n                    if (total_weight > 0) vel_u /= total_weight\n\n                    x = integrated_position[0] / CELL_SIZE[0] - 0.5\n                    y = integrated_position[1] / CELL_SIZE[1]\n\n                    i = Math.floor(x)\n                    j = Math.floor(y)\n\n                    dx = x - i\n                    dy = y - j\n\n                    b00 = this.in_bounds(i, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b10 = this.in_bounds(i + 1, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b01 = this.in_bounds(i, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n                    b11 = this.in_bounds(i + 1, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n                    w00 = (1 - dx) * (1 - dy) * (b00 && this.type[Math.min(i, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w10 = (dx) * (1 - dy) * (b10 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w01 = (1 - dx) * (dy) * (b01 && this.type[Math.min(i, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n                    w11 = (dx) * (dy) * (b11 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n\n                    total_weight = w00 + w10 + w01 + w11\n\n                    var vel_v = (\n                        this.velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] * w00 +\n                        this.velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] * w10 +\n                        this.velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] * w01 +\n                        this.velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] * w11\n                    )\n\n                    if (total_weight > 0) vel_v /= total_weight\n\n\n                    x = integrated_position[0] / CELL_SIZE[0]\n                    y = integrated_position[1] / CELL_SIZE[1] - 0.5\n\n                    i = Math.floor(x)\n                    j = Math.floor(y)\n\n                    dx = x - i\n                    dy = y - j\n\n                    b00 = this.in_bounds(i, j, this.velocity_u.length, this.velocity_u[0].length)\n                    b10 = this.in_bounds(i + 1, j, this.velocity_u.length, this.velocity_u[0].length)\n                    b01 = this.in_bounds(i, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n                    b11 = this.in_bounds(i + 1, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n\n                    w00 = (1 - dx) * (1 - dy) * (b00 && this.type[Math.min(i, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w10 = (dx) * (1 - dy) * (b10 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w01 = (1 - dx) * (dy) * (b01 && this.type[Math.min(i, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n                    w11 = (dx) * (dy) * (b11 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n\n                    total_weight = w00 + w10 + w01 + w11\n\n                    var last_vel_u = (\n                        this.last_velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] * w00 +\n                        this.last_velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] * w10 +\n                        this.last_velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] * w01 +\n                        this.last_velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] * w11\n                    )\n\n                    if (total_weight > 0) last_vel_u /= total_weight\n\n                    x = integrated_position[0] / CELL_SIZE[0] - 0.5\n                    y = integrated_position[1] / CELL_SIZE[1]\n\n                    i = Math.floor(x)\n                    j = Math.floor(y)\n\n                    dx = x - i\n                    dy = y - j\n\n                    b00 = this.in_bounds(i, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b10 = this.in_bounds(i + 1, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b01 = this.in_bounds(i, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n                    b11 = this.in_bounds(i + 1, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n                    w00 = (1 - dx) * (1 - dy) * (b00 && this.type[Math.min(i, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w10 = (dx) * (1 - dy) * (b10 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w01 = (1 - dx) * (dy) * (b01 && this.type[Math.min(i, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n                    w11 = (dx) * (dy) * (b11 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n\n                    total_weight = w00 + w10 + w01 + w11\n\n                    var last_vel_v = (\n                        this.last_velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] * w00 +\n                        this.last_velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] * w10 +\n                        this.last_velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] * w01 +\n                        this.last_velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] * w11\n                    )\n\n                    if (total_weight > 0) last_vel_v /= total_weight\n\n                    let flipFac = 0.93\n\n                    particle.velocity[0] = (vel_u) * (1 - flipFac) + (particle.velocity[0] + vel_u - last_vel_u) * flipFac\n                    particle.velocity[1] = (vel_v) * (1 - flipFac) + (particle.velocity[1] + vel_v - last_vel_v) * flipFac\n\n                    // Update particle position based on velocity\n                    particle.position[0] += particle.velocity[0] * dt\n                    particle.position[1] += particle.velocity[1] * dt\n\n                    this.insertParticleIntoHashTable(particle);\n                });\n            }\n\n          handle_collisions_and_boundary(dt) {\n                this.particles.forEach(particle => {\n                    // Update particle position based on velocity\n                    const x = particle.position[0];\n                    const y = particle.position[1];\n                    const r = particle.radius;\n\n                    // Handle boundary conditions\n                    if (x - r \u003C 0) {\n                        particle.velocity[0] *= 0;\n                        particle.position[0] = r;\n                    }\n                    if (x + r > BOUNDS[0]) {\n                        particle.velocity[0] *= 0;\n                        particle.position[0] = BOUNDS[0] - r;\n                    }\n                    if (y - r \u003C 0) {\n                        particle.velocity[1] *= 0;\n                        particle.position[1] = r;\n                    }\n                    if (y + r > BOUNDS[1]) {\n                        particle.velocity[1] *= 0;\n                        particle.position[1] = BOUNDS[1] - r;\n                    }\n\n                    var i = particle.position[0] / CELL_SIZE[0]\n                    var j = particle.position[1] / CELL_SIZE[1]\n\n\n                    // Push neighboring this.particles into the array\n                    var neighboringparticles = this.getparticlesFromHashTable(i, j);\n\n\n                    // Handle particle collisions\n                    neighboringparticles.forEach(other => {\n                        if (particle !== other) { // Ensure we're not checking the particle against itself\n\n                            var dx = other.position[0] - particle.position[0];\n                            var dy = other.position[1] - particle.position[1];\n                            const dist_squared = dx * dx + dy * dy;\n                            const min_dist_squared = (particle.radius + other.radius) ** 2;\n\n                            if (dist_squared \u003C min_dist_squared) {\n                                // Swap velocities\n                                const temp_velocity = particle.velocity.slice(); // Make a copy\n                                particle.velocity = other.velocity.slice();\n                                other.velocity = temp_velocity;\n\n                                // Calculate the direction of the collision\n                                const dist = Math.sqrt(dist_squared);\n                                const overlap = (particle.radius + other.radius) - dist;\n\n                                if (Math.abs(dist) > 0) {\n                                    dx /= dist\n                                    dy /= dist\n                                }\n\n                                // Move this.particles apart proportionally to their overlap\n                                const moveX = dx * overlap * 0.5;\n                                const moveY = dy * overlap * 0.5;\n\n                                // Move the this.particles in opposite directions\n                                particle.position[0] -= moveX;\n                                particle.position[1] -= moveY;\n                                \n                                other.position[0] += moveX;\n                                other.position[1] += moveY;\n                            }\n                        }\n                    });\n\n                    this.insertParticleIntoHashTable(particle);\n                });\n            }\n\n            insertParticleIntoHashTable(particle) {\n                var i = particle.position[0] / CELL_SIZE[0];\n                var j = particle.position[1] / CELL_SIZE[1];\n                const hash = this.hashCoords(i, j);\n\n                if (!this.particleHashTable[hash]) {\n                    this.particleHashTable[hash] = [];\n                }\n\n                this.particleHashTable[hash].push(particle);\n            }\n\n            getparticlesFromHashTable(i, j) {\n                i = Math.floor(i)\n                j = Math.floor(j)\n                const hash = this.hashCoords(i, j);\n                return this.particleHashTable[hash] || [];\n            }\n\n            hashCoords(i, j) {\n                i = Math.floor(i)\n                j = Math.floor(j)\n                var h = (i * 92837111) ^ (j * 689287499)\n                return Math.abs(h) % ((CELL_COUNT/4)**2)\n            }\n\n            clear() {\n                this.last_velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n                this.last_velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));\n                this.velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n                this.velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));\n                this.type = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n                this.pressure = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n            }\n\n            animate() {\n              this.update();\n              this.drawGrid();\n              requestAnimationFrame(this.animate);\n            }\n        }\n\n\n        lock = new Game();\n\n        document.getElementById('resetButton').addEventListener(\"click\", function(){lock.reset();})\n\n        document.addEventListener('DOMContentLoaded', function(){delete lock; lock = new Game(); lock.animate()});\n\n\u003C/script>\n\n### Conclusion\n\nThere are a few limitations to the program. The first is the instability of the simulator. \nDue to errors in the divergence calculation, high values of overrelaxation, or too many \niterations can cause the fluid to behave strangely. As well as this, this.particles will pop at times \nin the simulation. Ideally, improving the divergence calculation and removing the this.pressure, \noverrelaxation, and iteration settings altogether would make the tool a lot easier to use.\n\nThe second limitation is the time it takes to simulate the fluid. In further implementations, \nGPU support as well as a faster divergence calculation method would be included.\n\nThe third limitation, which is more of a problem with Maya, was not being able to \nhave relative image paths. Although a set-project method could work, It can be quite limiting \nas users may need to set-project elsewhere depending on their scene. Therefore, at the present \nmoment, Maya Fluid Simulator does not have any icons or images associated with it.\n\nOther limitations are small issues that, with time, will be sorted as the code evolves.\nAlthough the program is already quite comprehensive, plans for the future would be \nto implement inflow objects, colliders, and a meshing solution so that the fluids could be used \nmore for real productions\n\n*Written May 10, 2024 by Christopher Hosken*","src/content/posts/mfs.md","2365730c23c2fc32",{"html":218,"metadata":219},"\u003Cp>\u003Cimg src=\"/images/content/mfs/MayaFluidSimulator.PNG\" alt=\"Cover\">\u003C/p>\n\u003Ch2 id=\"overview\">Overview\u003C/h2>\n\u003Cp>Part of my Technical Arts Production unit at Bournemouth University required us to make a Maya tool with Python. I decided to challenge myself by looking into fluid simulators.\u003C/p>\n\u003Cp>*Maya Fluid Simulator *is a PIC/FLIP tool that allows you to simulate particle fluids.\u003C/p>\n\u003Cvideo controls muted>\n  \u003Csource src=\"/images/content/mfs/MFS_tutorial.mp4\" this.type=\"video/mp4\">\n\u003C/video>\n\u003Cp>More results can be seen at the bottom of this article.\u003C/p>\n\u003Ch2 id=\"maya-fluid-simulator-report\">Maya Fluid Simulator Report\u003C/h2>\n\u003Cp>\u003Cstrong>This report is a summary of the report created for the Technical Arts Production unit at Bournemouth University. If you wish to read the full report you can download it \u003Ca href=\"/images/content/mfs/mfs_report.pdf\">here\u003C/a>.\u003C/strong>\u003C/p>\n\u003Ch3 id=\"introduction\">Introduction\u003C/h3>\n\u003Cp>\u003Cem>Maya Fluid Simulator\u003C/em> is a PIC/FLIP tool that allows you to simulate particle fluids. Therefore it relies on the Navier Stokes equations.\u003C/p>\n\u003Cimg src=\"/images/content/mfs/navier.png\" style=\"max-width:600px; align-self: center; margin: 2em;\">\n\u003Cp>There are numerous ways to implement the Navier Stokes equations into a fluid simulator, aside from SPH (Smoothed Particle Hydrodynamics), two of the most popular methods are PIC (Particle in Cell), and FLIP (Fluid Implicit this.particles). Both methods combine Lagrangian simulation with Euler simulation.\u003C/p>\n\u003Cp>The Lagrangian simulation method relies on particle movement to describe fluid motion. This is often more realistic as fluid is (fundamentally) made of this.particles. However, this method can be extremely computationally expensive when calculating divergence and solving the this.pressure gradient. The Euler method combats this computational time by storing velocity, density, and other attributes within a grid. This is often the preferred method for gas-based simulations such as fire and smoke, as it is much faster to calculate. However, the particle-like nature of the fluid is lost.\u003C/p>\n\u003Cp>PIC and FLIP combine the particle-like nature of lagrangian simulations with the speed of Eulerian. The method is explained below.\u003C/p>\n\u003Cul>\n\u003Cli>Particle velocities are transferred to the grid and density is calculated. The velocity grid is then copied\u003C/li>\n\u003Cli>A timestep is calculated\u003C/li>\n\u003Cli>Boundaries are enforced\u003C/li>\n\u003Cli>Fluid is made divergence-free\u003C/li>\n\u003Cli>Velocity is transferred to the this.particles using the old and new velocity grids\u003C/li>\n\u003Cli>Particle collisions are handled\u003C/li>\n\u003C/ul>\n\u003Cbr>\n\u003Ch3 id=\"particle-to-grid-and-grid-to-particle\">Particle to Grid and Grid to Particle\u003C/h3>\n\u003Cp>One of the most important parts of the algorithm was transferring velocity between the this.particles and the grid. This was done through trilinear interpolation on a staggered grid. A staggered grid offsets the position of certain attributes so that they can be interpolated and averaged correctly.\u003C/p>\n\u003Cimg src=\"/images/content/mfs/p2g.png\" style=\"max-width:400px; align-self: center; margin: 2em;\">\n\u003Cp>this.pressure was stored in an array the size of the domain resolution, whilst velocities were stored in arrays with a size +1 on their corresponding index.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"py\">\u003Ccode>\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">    self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.velocity_u \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> np.zeros((\u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">0\u003C/span>\u003Cspan style=\"color:#E1E4E8\">]\u003C/span>\u003Cspan style=\"color:#F97583\">+\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">], \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">2\u003C/span>\u003Cspan style=\"color:#E1E4E8\">]), \u003C/span>\u003Cspan style=\"color:#FFAB70\">dtype\u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"float64\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">    self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.velocity_v \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> np.zeros((\u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">0\u003C/span>\u003Cspan style=\"color:#E1E4E8\">], \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">]\u003C/span>\u003Cspan style=\"color:#F97583\">+\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">, \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">2\u003C/span>\u003Cspan style=\"color:#E1E4E8\">]), \u003C/span>\u003Cspan style=\"color:#FFAB70\">dtype\u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"float64\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">    self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.velocity_w \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> np.zeros((\u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">0\u003C/span>\u003Cspan style=\"color:#E1E4E8\">], \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">], \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">2\u003C/span>\u003Cspan style=\"color:#E1E4E8\">]\u003C/span>\u003Cspan style=\"color:#F97583\">+\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">), \u003C/span>\u003Cspan style=\"color:#FFAB70\">dtype\u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"float64\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">    self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.pressure \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> np.zeros((\u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">0\u003C/span>\u003Cspan style=\"color:#E1E4E8\">], \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">], \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">2\u003C/span>\u003Cspan style=\"color:#E1E4E8\">]), \u003C/span>\u003Cspan style=\"color:#FFAB70\">dtype\u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#9ECBFF\">\"float64\"\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">    \u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cimg src=\"/images/content/mfs/trillinear.png\" style=\"max-width:400px; align-self: center; margin: 2em;\">\n\u003Cp>The weights were calculated by finding the particle offset in cell space (dx =  x - int(x)), and then multiplying by an in_bounds() check. This means any velocity values outside the domain (which don’t exist), don’t contribute to the trilinear interpolation.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"py\">\u003Ccode>\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">c000 \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#F97583\"> -\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> dx) \u003C/span>\u003Cspan style=\"color:#F97583\">*\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#F97583\"> -\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> dy) \u003C/span>\u003Cspan style=\"color:#F97583\">*\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#F97583\"> -\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> dz) \u003C/span>\u003Cspan style=\"color:#F97583\">*\u003C/span>\u003Cspan style=\"color:#79B8FF\"> self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.in_bounds(i, j, k, resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">0\u003C/span>\u003Cspan style=\"color:#E1E4E8\">], resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">], resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">2\u003C/span>\u003Cspan style=\"color:#E1E4E8\">])\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">...\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>The first line is how velocity would be transferred from a particle to the grid. The second line is the inverse; grid to particle.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"py\">\u003Ccode>\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.velocity_v[\u003C/span>\u003Cspan style=\"color:#79B8FF\">min\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(i, \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">0\u003C/span>\u003Cspan style=\"color:#E1E4E8\">] \u003C/span>\u003Cspan style=\"color:#F97583\">-\u003C/span>\u003Cspan style=\"color:#79B8FF\"> 1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)][\u003C/span>\u003Cspan style=\"color:#79B8FF\">min\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(j, \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">])][\u003C/span>\u003Cspan style=\"color:#79B8FF\">min\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(k, \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">2\u003C/span>\u003Cspan style=\"color:#E1E4E8\">] \u003C/span>\u003Cspan style=\"color:#F97583\">-\u003C/span>\u003Cspan style=\"color:#79B8FF\"> 1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)] \u003C/span>\u003Cspan style=\"color:#F97583\">+=\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> p.velocity[\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">] \u003C/span>\u003Cspan style=\"color:#F97583\">*\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> c000\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">velocity_v \u003C/span>\u003Cspan style=\"color:#F97583\">+=\u003C/span>\u003Cspan style=\"color:#79B8FF\"> self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.velocity_v[\u003C/span>\u003Cspan style=\"color:#79B8FF\">min\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(i, \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">0\u003C/span>\u003Cspan style=\"color:#E1E4E8\">]\u003C/span>\u003Cspan style=\"color:#F97583\">-\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)][\u003C/span>\u003Cspan style=\"color:#79B8FF\">min\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(j, \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">] )][\u003C/span>\u003Cspan style=\"color:#79B8FF\">min\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(k, \u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.resolution[\u003C/span>\u003Cspan style=\"color:#79B8FF\">2\u003C/span>\u003Cspan style=\"color:#E1E4E8\">] \u003C/span>\u003Cspan style=\"color:#F97583\">-\u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">)] \u003C/span>\u003Cspan style=\"color:#F97583\">*\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> c000\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>To keep the simulation stable, velocities must be normalised by the sum of their weights. An average this.pressure value must also be calculated for the first frame of the simulation. This is very important for making sure the divergence calculation is correct.\u003C/p>\n\u003Ch3 id=\"finding-dt\">Finding dt\u003C/h3>\n\u003Cp>With Lagrangian simulations, a timestep can remain constant as the this.particles aren’t\ntraversing any grids. In PIC and FLIP, however, the this.particles cannot skip over cells, as doing\nso may destabilise the simulation. Therefore, a timestep needs to be calculated. This concept\nis the CFL (Courant–Friedrichs–Lewy) condition. The technique implemented below was\ninspired by Robert Bridson.\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"py\">\u003Ccode>\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#F97583\">    def\u003C/span>\u003Cspan style=\"color:#B392F0\"> calc_dt\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(self, particles, timescale, external_force):\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">        max_speed \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#79B8FF\"> 0\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#F97583\">        for\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> particle \u003C/span>\u003Cspan style=\"color:#F97583\">in\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> particles:\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">            speed \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> np.linalg.norm(particle.velocity)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">            max_speed \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#79B8FF\"> max\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(max_speed, speed)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">        max_dist \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> np.linalg.norm(\u003C/span>\u003Cspan style=\"color:#79B8FF\">self\u003C/span>\u003Cspan style=\"color:#E1E4E8\">.cell_size) \u003C/span>\u003Cspan style=\"color:#F97583\">*\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> np.linalg.norm(external_force)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#F97583\">        if\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> (max_speed \u003C/span>\u003Cspan style=\"color:#F97583\">&#x3C;=\u003C/span>\u003Cspan style=\"color:#79B8FF\"> 0\u003C/span>\u003Cspan style=\"color:#E1E4E8\">):\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#E1E4E8\">            max_speed \u003C/span>\u003Cspan style=\"color:#F97583\">=\u003C/span>\u003Cspan style=\"color:#79B8FF\"> 1\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#F97583\">        return\u003C/span>\u003Cspan style=\"color:#79B8FF\"> min\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(timescale, \u003C/span>\u003Cspan style=\"color:#79B8FF\">max\u003C/span>\u003Cspan style=\"color:#E1E4E8\">(timescale \u003C/span>\u003Cspan style=\"color:#F97583\">*\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> max_dist \u003C/span>\u003Cspan style=\"color:#F97583\">/\u003C/span>\u003Cspan style=\"color:#E1E4E8\"> max_speed, \u003C/span>\u003Cspan style=\"color:#79B8FF\">1\u003C/span>\u003Cspan style=\"color:#E1E4E8\">))\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>The function finds the fastest particle and calculates a timestep so that the particle would move only 1 grid cell. A timescale variable is used so users can set the visual speed of the simulation.\u003C/p>\n\u003Ch3 id=\"enforcing-boundaries-and-solving-divergence\">Enforcing Boundaries and Solving Divergence\u003C/h3>\n\u003Cp>Enforcing boundaries is extremely simple. Using the Neumann Boundary condition, all boundary velocity components that point out of the domain are set to 0. The loss of velocity is then corrected when the divergence is solved.\u003C/p>\n\u003Cp>There are numerous ways to make the fluid velocity field divergence-free, but the easiest to implement is the Gauss-Seidel method (a modern version of the Jacobi method). Divergence is calculated by finding the velocity difference in each cell, then a this.pressure force is subtracted.\u003C/p>\n\u003Cp>A border value is then calculated to spread the divergence evenly along each velocity component.\u003C/p>\n\u003Ch3 id=\"particle-collisions\">Particle Collisions\u003C/h3>\n\u003Cp>Two this.types of collisions need to be handled in the simulation: domain and particle.\nHandling domain collisions is relatively simple. Integrate the particle, then check if its\nposition is outside the domain. If so,  zero its velocity (across the axis), and set the particle\nposition to the boundary edge.\u003C/p>\n\u003Cp>As the number of this.particles increases, the time needed to calculate particle collisions\nincreases dramatically. To combat this, Hash mapping was implemented. Hash mapping\nassigns close this.particles to the same array, heavily reducing the number of collision tests\nbetween this.particles.\u003C/p>\n\u003Ch3 id=\"pic-and-flip\">PIC and FLIP\u003C/h3>\n\u003Cp>Although PIC and FLIP follow (essentially) the same code structure. The way they\naffect particle velocity is slightly different. For PIC, velocity from the grid is directly\nassigned to the particle velocity. For FLIP, a velocity difference is calculated between the old\ngrid (particle to grid) and the grid after all the force and divergence calculations. The velocity\ndifference is then added to the particle velocity.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/content/mfs/picflip.png\" alt=\"PIC and FLIP\">\u003C/p>\n\u003Cp>PIC is usually more viscous, and FLIP is usually more splashy. The purpose of the\nPIC/FLIP slider is so that users can choose how much viscosity they want the fluid to have.\nThis is also why the viscosity force was left out of the code.\u003C/p>\n\u003Ch3 id=\"results\">Results\u003C/h3>\n\u003Cp>Below are some benchmark tests for \u003Cem>Maya Fluid Simulator\u003C/em>. Tests were run on Windows 10 Enterprise with an Intel i7-13700, 64GB RAM, and NVIDIA GeForce RTX 4080.\u003C/p>\n\u003Cp>The Default Donut simulation had a particle count of 4800. A particle scale of 0.1 and a PIC/FLIP Mix of 0.6. It simulated 120 frames in 3 minutes 33 seconds.\n\u003Cvideo controls muted>\n\u003Csource src=\"/images/content/mfs/MFS_DefaultDonut.mp4\" this.type=\"video/mp4\">\n\u003C/video>\u003C/p>\n\u003Cp>The Dam Break simulation had a particle count of 15000. A particle scale of 0.1 and a PIC/FLIP Mix of 0.8. It simulated 120 frames in 9 minutes 20 seconds.\n\u003Cvideo controls muted>\n\u003Csource src=\"/images/content/mfs/MFS_DamBreak.mp4\" this.type=\"video/mp4\">\n\u003C/video>\u003C/p>\n\u003Cp>The Honey simulation had a particle count of 4800. A particle scale of 0.2 and a PIC/FLIP Mix of 0.0. It simulated 120 frames in 1 minute 8 seconds.\n\u003Cvideo controls muted>\n\u003Csource src=\"/images/content/mfs/MFS_Honey.mp4\" this.type=\"video/mp4\">\n\u003C/video>\u003C/p>\n\u003Ch3 id=\"js-simulator\">JS Simulator\u003C/h3>\n\u003Cp>This a simple 2D version of the simulator that was used for debugging the Maya python code.\n\u003Cbr> \u003Cbr>\n\u003Cem>\u003Cstrong>WARNING MAY SLOW DOWN DEVICE\u003C/strong>\u003C/em>\u003C/p>\n\u003Cdiv width=\"100%\" style=\"display: flex; flex-direction: column;\">\n\u003Cbutton id=\"resetButton\" style=\"width:5em;height:2em;font-size:1em;margin:1em auto;justify-self:center;\"> Restart \u003C/button>\n\u003Ccanvas id=\"particleCanvas\" width=\"300\" height=\"300\" style=\"margin: 0 auto; justify-self: center;\">\u003C/canvas>\n\u003C/div>\n\u003Cscript>\n        const canvas = document.getElementById('particleCanvas');\n        const canvasWidth = canvas.width;  // Get canvas width\n        const canvasHeight = canvas.height; // Get canvas height\n        var CELL_COUNT = canvas.width/20;\n        var BOUNDS = [canvas.width, canvas.height]\n        var CELL_SIZE = [BOUNDS[0] / CELL_COUNT, BOUNDS[1] / CELL_COUNT]\n        var GRID_SIZE = canvas.width/10;\n        var OFFSET = [canvas.width/2, -canvas.height/2]\n        var PSCALE = canvas.width/100;\n        var EXTERNAL = [0, 98];\n        var AVERAGE = -1\n\n        function HSVtoRGB(h, s, v) {\n            let c = v * s;\n            let hp = (h / 60) % 6;\n            let x = c * (1 - Math.abs(hp % 2 - 1));\n            let rgb = [0, 0, 0];\n\n            if (0 \u003C= hp && hp \u003C 1) {\n                rgb = [c, x, 0];\n            } else if (1 \u003C= hp && hp \u003C 2) {\n                rgb = [x, c, 0];\n            } else if (2 \u003C= hp && hp \u003C 3) {\n                rgb = [0, c, x];\n            } else if (3 \u003C= hp && hp \u003C 4) {\n                rgb = [0, x, c];\n            } else if (4 \u003C= hp && hp \u003C 5) {\n                rgb = [x, 0, c];\n            } else if (5 \u003C= hp && hp \u003C 6) {\n                rgb = [c, 0, x];\n            }\n\n            let m = v - c;\n            rgb[0] += m;\n            rgb[1] += m;\n            rgb[2] += m;\n\n            // Scale RGB values to the range [0, 255]\n            return rgb.map(val => Math.round(val * 255));\n        }\n\n        class Particle {\n            constructor(x, y, radius) {\n                this.position = [x, y];\n                this.velocity = [-50.0, 500.0];\n                this.radius = radius;\n            }\n            draw(ctx) {\n                ctx.beginPath();\n                ctx.arc(this.position[0], this.position[1], this.radius, 0, Math.PI * 2);\n\n                var speed = Math.sqrt(this.velocity[0] * this.velocity[0] + this.velocity[1] * this.velocity[1])\n\n                speed = Math.sqrt(speed) / 6\n\n                let rgbColor = HSVtoRGB(200, Math.max(3 / speed, 0.01), Math.max(speed, 0.7));\n\n                ctx.fillStyle = `rgb(${rgbColor[0]}, ${rgbColor[1]}, ${rgbColor[2]})`;\n                ctx.strokeStyle = \"black\"\n                ctx.fill();\n                //this.ctx.stroke();\n            }\n        }\n\n        class Game {\n          constructor(){\n            this.canvas = document.getElementById('particleCanvas');\n            this.ctx = this.canvas.getContext('2d');\n\n            this.reset();\n\n            this.animate = this.animate.bind(this);\n          }\n\n          reset() {\n            this.particles = new Array(GRID_SIZE * GRID_SIZE).fill(null)\n            this.velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n            this.velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));\n\n            this.last_velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n            this.last_velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));\n\n            this.type = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n            this.pressure = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n\n            this.particleHashTable = {};\n\n            for (let o = 0; o \u003C GRID_SIZE; o++) {\n                for (let p = 0; p \u003C GRID_SIZE; p++) {\n                    const index = o * GRID_SIZE + p\n                    this.particles[index] = new Particle(\n                        (o + 0.5) * (PSCALE * 2) + OFFSET[0],\n                        (p + 0.5) * (PSCALE * 2) + OFFSET[1] + (PSCALE * 2 * GRID_SIZE),\n                        PSCALE\n                    );\n                }\n            }\n          }\n\n\n          update() {\n                this.clear()\n                var tscale = 0.05\n                let average = this.particle_to_grid()\n                if (AVERAGE == -1) {\n                    AVERAGE = average\n                } \n                let dt = this.calc_dt(tscale)\n                this.calc_forces(dt)\n                this.enforce_boundaries()\n                this.solve_divergence(AVERAGE)\n                this.particle_from_grid(dt)\n                this.handle_collisions_and_boundary(dt)\n\n            }\n\n          drawGrid() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n                if (true) {\n                    for (let i = 0; i \u003C CELL_COUNT; i += 1) {\n                        for (let j = 0; j \u003C CELL_COUNT; j += 1) {\n                            this.ctx.beginPath();\n                            this.ctx.strokeStyle = \"black\"\n                            this.ctx.strokeRect(i * CELL_SIZE[0], (j * CELL_SIZE[1]), CELL_SIZE[0], CELL_SIZE[1]);\n\n                            if (false) {\n                                if (this.type[i][j] == 1) {\n                                    this.ctx.fillStyle = \"blue\"\n                                    this.ctx.fillRect(i * CELL_SIZE[0],  (j * CELL_SIZE[1]), CELL_SIZE[0], CELL_SIZE[1]);\n                                }\n                                this.ctx.stroke();\n                            }\n\n                            if (false) {\n\n                            this.ctx.beginPath();\n                            this.ctx.arc((i + 0.5) * CELL_SIZE[0], ((j + 0.5) * CELL_SIZE[1]), Math.sqrt(this.pressure[i][j] * 10), 0, Math.PI * 2);\n                            this.ctx.fillStyle = \"green\"\n                            this.ctx.fill();\n                            this.ctx.stroke();\n                            }\n                        }\n                    }\n                \n                }\n\n                if (false) {\n\n                    for (let ux = 0; ux \u003C this.velocity_u.length; ux += 1) {\n                        for (let uy = this.velocity_u[0].length - 1; uy >= 0; uy -= 1) {\n                            this.ctx.beginPath();\n                            var v = Math.sqrt(Math.abs(this.velocity_u[ux][uy])) * 0.5\n                            this.ctx.arc((ux) * CELL_SIZE[0], ((uy + 0.5) * CELL_SIZE[1]), v, 0, Math.PI * 2);\n                            this.ctx.fillStyle = \"red\"\n                            this.ctx.fill();\n                            this.ctx.stroke();\n                        }\n                    }\n\n                    // Draw horizontal lines\n                    for (let vx = 0; vx \u003C this.velocity_v.length; vx += 1) {\n                        for (let vy = this.velocity_v[0].length - 1; vy >= 0; vy -= 1) {\n                            this.ctx.beginPath();\n                            var v = Math.sqrt(Math.abs(this.velocity_v[vx][vy])) * 0.5\n                            this.ctx.arc((vx + 0.5) * CELL_SIZE[0], ((vy) * CELL_SIZE[1]), v, 0, Math.PI * 2);\n                            this.ctx.fillStyle = \"green\"\n                            this.ctx.fill();\n                            this.ctx.stroke();\n                        }\n                    }\n                }\n\n                if (true) {\n                    this.particles.forEach(particle => {\n                        particle.draw(this.ctx);\n                    });\n                }\n\n            }\n\n          particle_to_grid() {\n                let weight_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n                let weight_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));\n\n                this.particles.forEach(particle => {\n                    let x = particle.position[0] / CELL_SIZE[0]\n                    let y = particle.position[1] / CELL_SIZE[1] - 0.5\n\n                    let i = Math.floor(x)\n                    let j = Math.floor(y)\n\n                    let dx = x - i\n                    let dy = y - j\n\n                    let b00 = this.in_bounds(i, j, this.velocity_u.length, this.velocity_u[0].length)\n                    let b10 = this.in_bounds(i + 1, j, this.velocity_u.length, this.velocity_u[0].length)\n                    let b01 = this.in_bounds(i, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n                    let b11 = this.in_bounds(i + 1, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n                    \n                    let w00 = (1 - dx) * (1 - dy) * b00\n                    let w10 = (dx) * (1 - dy) * b10\n                    let w01 = (1 - dx) * (dy) * b01\n                    let w11 = (dx) * (dy) * b11\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n                    this.last_velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] += w00 * particle.velocity[0]\n                    weight_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] += w00\n\n                    this.last_velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] += w10 * particle.velocity[0]\n                    weight_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] += w10\n\n                    this.last_velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] += w01 * particle.velocity[0]\n                    weight_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] += w01\n\n                    this.last_velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] += w11 * particle.velocity[0]\n                    weight_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] += w11\n\n\n                    x = particle.position[0] / CELL_SIZE[0] - 0.5\n                    y = particle.position[1] / CELL_SIZE[1]\n\n                    i = Math.floor(x)\n                    j = Math.floor(y)\n\n                    dx = x - i\n                    dy = y - j\n\n                    b00 = this.in_bounds(i, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b10 = this.in_bounds(i + 1, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b01 = this.in_bounds(i, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n                    b11 = this.in_bounds(i + 1, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n\n                    w00 = (1 - dx) * (1 - dy) * b00\n                    w10 = (dx) * (1 - dy) * b10\n                    w01 = (1 - dx) * (dy) * b01\n                    w11 = (dx) * (dy) * b11\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n                    this.last_velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] += w00 * particle.velocity[1]\n                    weight_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] += w00\n\n                    this.last_velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] += w10 * particle.velocity[1]\n                    weight_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] += w10\n\n                    this.last_velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] += w01 * particle.velocity[1]\n                    weight_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] += w01\n\n                    this.last_velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] += w11 * particle.velocity[1]\n                    weight_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] += w11\n\n                    x = particle.position[0] / CELL_SIZE[0] - 0.5\n                    y = particle.position[1] / CELL_SIZE[1] - 0.5\n\n                    i = Math.floor(x)\n                    j = Math.floor(y)\n\n                    dx = x - i\n                    dy = y - j\n\n                    b00 = this.in_bounds(i, j, this.pressure.length, this.pressure[0].length)\n                    b10 = this.in_bounds(i + 1, j, this.pressure.length, this.pressure[0].length)\n                    b01 = this.in_bounds(i, j + 1, this.pressure.length, this.pressure[0].length)\n                    b11 = this.in_bounds(i + 1, j + 1, this.pressure.length, this.pressure[0].length)\n\n                    w00 = (1 - dx) * (1 - dy) * b00\n                    w10 = (dx) * (1 - dy) * b10\n                    w01 = (1 - dx) * (dy) * b01\n                    w11 = (dx) * (dy) * b11\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n                    this.pressure[Math.min(i, this.pressure.length - 1)][Math.min(j, this.pressure[0].length - 1)] += w00\n\n                    this.pressure[Math.min(i + 1, this.pressure.length - 1)][Math.min(j, this.pressure[0].length - 1)] += w10\n\n\n                    this.pressure[Math.min(i, this.pressure.length - 1)][Math.min(j + 1, this.pressure[0].length - 1)] += w01\n\n                    this.pressure[Math.min(i + 1, this.pressure.length - 1)][Math.min(j + 1, this.pressure[0].length - 1)] += w11\n\n                    x = particle.position[0] / CELL_SIZE[0]\n                    y = particle.position[1] / CELL_SIZE[1]\n\n                    i = Math.max(Math.min(Math.floor(x), this.type.length - 1), 0)\n                    j = Math.max(Math.min(Math.floor(y), this.type[0].length - 1), 0)\n\n                    this.type[i][j] = 1\n                })\n\n                for (let ux = 0; ux \u003C this.velocity_u.length; ux++) {\n                    for (let uy = 0; uy \u003C this.velocity_u[0].length; uy++) {\n                        if (weight_u[ux][uy] > 0) {\n                            this.last_velocity_u[ux][uy] /= weight_u[ux][uy]\n                        }\n                    }\n                }\n\n                for (let vx = 0; vx \u003C this.velocity_v.length; vx++) {\n                    for (let vy = 0; vy \u003C this.velocity_v[0].length; vy++) {\n                        if (weight_v[vx][vy] > 2) {\n                            this.last_velocity_v[vx][vy] /= weight_v[vx][vy]\n                        }\n                    }\n                }\n\n\n                for (let ux = 0; ux \u003C this.velocity_u.length; ux++) {\n                    for (let uy = 0; uy \u003C this.velocity_u[0].length; uy++) {\n                        this.velocity_u[ux][uy] = this.last_velocity_u[ux][uy]\n                    }\n                }\n\n                for (let vx = 0; vx \u003C this.velocity_v.length; vx++) {\n                    for (let vy = 0; vy \u003C this.velocity_v[0].length; vy++) {\n                        this.velocity_v[vx][vy] = this.last_velocity_v[vx][vy]\n                    }\n                }\n\n                let num_fluid_cells = 0\n                let average_density = 0\n\n                for (let i = 0; i \u003C CELL_COUNT; i++) {\n                    for (let j = 0; j \u003C CELL_COUNT; j++) {\n                        if (this.type[i][j] == 1) {\n                            num_fluid_cells += 1\n                            average_density += this.pressure[i][j]\n                        }\n                    }\n                }\n\n                if (num_fluid_cells > 0) average_density /= num_fluid_cells\n\n                return average_density\n            }\n\n          in_bounds(i, j, lx, ly) {\n                return (\n                    0 \u003C= i \u003C lx &&\n                    0 \u003C= j \u003C ly\n                )\n            }\n\n          calc_dt(tscale) {\n                var max_speed = 0\n                this.particles.forEach(particle => {\n                    const speed_squared = particle.velocity[0] ** 2 + particle.velocity[1] ** 2\n                    max_speed = Math.max(speed_squared, max_speed)\n                })\n\n                max_speed = Math.sqrt(max_speed)\n\n                let max_dist = Math.sqrt((CELL_SIZE[0] ** 2 + CELL_SIZE[1] ** 2) * Math.sqrt(EXTERNAL[0] ** 2 + EXTERNAL[1] ** 2))\n\n                return Math.min(tscale, tscale * max_dist / max_speed, 1)\n            }\n\n          calc_forces(dt) {\n                let TOTAL_FORCE = [\n                    EXTERNAL[0],\n                    EXTERNAL[1]\n                ]\n\n                for (let ux = 0; ux \u003C this.velocity_u.length; ux++) {\n                    for (let uy = 0; uy \u003C this.velocity_u[0].length; uy++) {\n                        this.velocity_u[ux][uy] += EXTERNAL[0] * dt\n                    }\n                }\n\n                for (let vx = 0; vx \u003C this.velocity_v.length; vx++) {\n                    for (let vy = 0; vy \u003C this.velocity_v[0].length; vy++) {\n                        this.velocity_v[vx][vy] += EXTERNAL[1] * dt\n                    }\n                }\n            }\n\n          enforce_boundaries() {\n                for (let uy = 0; uy \u003C this.velocity_u[0].length; uy++) {\n                    if (this.velocity_u[0][uy] \u003C 0) this.velocity_u[0][uy] = 0\n                    if (this.velocity_u[this.velocity_u.length - 1][uy] > 0) this.velocity_u[this.velocity_u.length - 1][uy] = 0\n                }\n\n                for (let vx = 0; vx \u003C this.velocity_v.length; vx++) {\n                    if (this.velocity_v[vx][0] \u003C 0) this.velocity_v[vx][0] = 0\n                    if (this.velocity_v[vx][this.velocity_v[0].length - 1] > 0) this.velocity_v[vx][this.velocity_v[0].length - 1] = 0\n                }\n            }\n\n            // Function to compute the divergence of the velocity field\n          compute_divergence(vel_u, vel_v, CELL_COUNT, CELL_SIZE, average) {\n                let divergence = [];\n                for (let i = 0; i \u003C CELL_COUNT; i++) {\n                    divergence[i] = [];\n                    for (let j = 0; j \u003C CELL_COUNT; j++) {\n                        divergence[i][j] = 1.9 * (\n                            (vel_u[i + 1][j] - vel_u[i][j]) / (1 * CELL_SIZE[0]) +\n                            (vel_v[i][j + 1] - vel_v[i][j]) / (1 * CELL_SIZE[1])\n                        ) - 3 * (this.pressure[i][j] - average)\n                    }\n                }\n                return divergence;\n            }\n\n\n            // Function to solve divergence\n          solve_divergence(average) {\n                const tolerance = 0.1\n                const maxIterations = 1;\n\n                for (let n = 0; n \u003C maxIterations; n++) {\n                    const previousDivergence = this.compute_divergence(this.velocity_u, this.velocity_v, CELL_COUNT, CELL_SIZE, average);\n\n                    for (let i = 0; i \u003C CELL_COUNT; i++) {\n                        for (let j = 0; j \u003C CELL_COUNT; j++) {\n                            const borders = (\n                                this.in_bounds(i - 1, j, CELL_COUNT, CELL_COUNT) +\n                                this.in_bounds(i + 1, j, CELL_COUNT, CELL_COUNT) +\n                                this.in_bounds(i, j - 1, CELL_COUNT, CELL_COUNT) +\n                                this.in_bounds(i, j + 1, CELL_COUNT, CELL_COUNT)\n                            );\n\n                            const divergence = previousDivergence[i][j];\n                            this.velocity_u[i][j] += divergence * this.in_bounds(i - 1, j, CELL_COUNT, CELL_COUNT) / borders;\n                            this.velocity_u[i + 1][j] -= divergence * this.in_bounds(i + 1, j, CELL_COUNT, CELL_COUNT) / borders;\n                            this.velocity_v[i][j] += divergence * this.in_bounds(i, j - 1, CELL_COUNT, CELL_COUNT) / borders;\n                            this.velocity_v[i][j + 1] -= divergence * this.in_bounds(i, j + 1, CELL_COUNT, CELL_COUNT) / borders;\n                        }\n                    }\n\n                    const currentDivergence = this.compute_divergence(this.velocity_u, this.velocity_v, CELL_COUNT, CELL_SIZE, average);\n\n                    // Compute the change in divergence\n                    let divergenceChange = 0;\n                    for (let i = 0; i \u003C CELL_COUNT; i++) {\n                        for (let j = 0; j \u003C CELL_COUNT; j++) {\n                            divergenceChange += Math.abs(currentDivergence[i][j] - previousDivergence[i][j]);\n                        }\n                    }\n\n                    if (divergenceChange \u003C= tolerance) break;\n                }\n            }\n\n          particle_from_grid(dt) {\n                // Advect this.particles\n                this.particles.forEach(particle => {\n\n                    let integrated_position = [particle.position[0] + particle.velocity[0] * dt, particle.position[1]+ particle.velocity[1] * dt]\n\n                    let x = integrated_position[0] / CELL_SIZE[0]\n                    let y = integrated_position[1] / CELL_SIZE[1] - 0.5\n\n                    let i = Math.floor(x)\n                    let j = Math.floor(y)\n\n                    let dx = x - i\n                    let dy = y - j\n\n                    let b00 = this.in_bounds(i, j, this.velocity_u.length, this.velocity_u[0].length)\n                    let b10 = this.in_bounds(i + 1, j, this.velocity_u.length, this.velocity_u[0].length)\n                    let b01 = this.in_bounds(i, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n                    let b11 = this.in_bounds(i + 1, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n\n                    let w00 = (1 - dx) * (1 - dy) * (b00 && this.type[Math.min(i, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    let w10 = (dx) * (1 - dy) * (b10 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    let w01 = (1 - dx) * (dy) * (b01 && this.type[Math.min(i, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n                    let w11 = (dx) * (dy) * (b11 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n\n                    let total_weight = w00 + w10 + w01 + w11\n\n                    var vel_u = (\n                        this.velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] * w00 +\n                        this.velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] * w10 +\n                        this.velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] * w01 +\n                        this.velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] * w11\n                    )\n\n                    if (total_weight > 0) vel_u /= total_weight\n\n                    x = integrated_position[0] / CELL_SIZE[0] - 0.5\n                    y = integrated_position[1] / CELL_SIZE[1]\n\n                    i = Math.floor(x)\n                    j = Math.floor(y)\n\n                    dx = x - i\n                    dy = y - j\n\n                    b00 = this.in_bounds(i, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b10 = this.in_bounds(i + 1, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b01 = this.in_bounds(i, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n                    b11 = this.in_bounds(i + 1, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n                    w00 = (1 - dx) * (1 - dy) * (b00 && this.type[Math.min(i, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w10 = (dx) * (1 - dy) * (b10 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w01 = (1 - dx) * (dy) * (b01 && this.type[Math.min(i, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n                    w11 = (dx) * (dy) * (b11 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n\n                    total_weight = w00 + w10 + w01 + w11\n\n                    var vel_v = (\n                        this.velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] * w00 +\n                        this.velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] * w10 +\n                        this.velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] * w01 +\n                        this.velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] * w11\n                    )\n\n                    if (total_weight > 0) vel_v /= total_weight\n\n\n                    x = integrated_position[0] / CELL_SIZE[0]\n                    y = integrated_position[1] / CELL_SIZE[1] - 0.5\n\n                    i = Math.floor(x)\n                    j = Math.floor(y)\n\n                    dx = x - i\n                    dy = y - j\n\n                    b00 = this.in_bounds(i, j, this.velocity_u.length, this.velocity_u[0].length)\n                    b10 = this.in_bounds(i + 1, j, this.velocity_u.length, this.velocity_u[0].length)\n                    b01 = this.in_bounds(i, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n                    b11 = this.in_bounds(i + 1, j + 1, this.velocity_u.length, this.velocity_u[0].length)\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n\n                    w00 = (1 - dx) * (1 - dy) * (b00 && this.type[Math.min(i, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w10 = (dx) * (1 - dy) * (b10 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w01 = (1 - dx) * (dy) * (b01 && this.type[Math.min(i, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n                    w11 = (dx) * (dy) * (b11 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n\n                    total_weight = w00 + w10 + w01 + w11\n\n                    var last_vel_u = (\n                        this.last_velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] * w00 +\n                        this.last_velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j, this.velocity_u[0].length - 1)] * w10 +\n                        this.last_velocity_u[Math.min(i, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] * w01 +\n                        this.last_velocity_u[Math.min(i + 1, this.velocity_u.length - 1)][Math.min(j + 1, this.velocity_u[0].length - 1)] * w11\n                    )\n\n                    if (total_weight > 0) last_vel_u /= total_weight\n\n                    x = integrated_position[0] / CELL_SIZE[0] - 0.5\n                    y = integrated_position[1] / CELL_SIZE[1]\n\n                    i = Math.floor(x)\n                    j = Math.floor(y)\n\n                    dx = x - i\n                    dy = y - j\n\n                    b00 = this.in_bounds(i, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b10 = this.in_bounds(i + 1, j, this.velocity_v.length, this.velocity_v[0].length)\n                    b01 = this.in_bounds(i, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n                    b11 = this.in_bounds(i + 1, j + 1, this.velocity_v.length, this.velocity_v[0].length)\n\n                    i = Math.max(0, i)\n                    j = Math.max(0, j)\n\n                    w00 = (1 - dx) * (1 - dy) * (b00 && this.type[Math.min(i, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w10 = (dx) * (1 - dy) * (b10 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j, this.type[0].length - 1)] != 2)\n                    w01 = (1 - dx) * (dy) * (b01 && this.type[Math.min(i, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n                    w11 = (dx) * (dy) * (b11 && this.type[Math.min(i + 1, this.type.length - 1)][Math.min(j + 1, this.type[0].length - 1)] != 2)\n\n                    total_weight = w00 + w10 + w01 + w11\n\n                    var last_vel_v = (\n                        this.last_velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] * w00 +\n                        this.last_velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j, this.velocity_v[0].length - 1)] * w10 +\n                        this.last_velocity_v[Math.min(i, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] * w01 +\n                        this.last_velocity_v[Math.min(i + 1, this.velocity_v.length - 1)][Math.min(j + 1, this.velocity_v[0].length - 1)] * w11\n                    )\n\n                    if (total_weight > 0) last_vel_v /= total_weight\n\n                    let flipFac = 0.93\n\n                    particle.velocity[0] = (vel_u) * (1 - flipFac) + (particle.velocity[0] + vel_u - last_vel_u) * flipFac\n                    particle.velocity[1] = (vel_v) * (1 - flipFac) + (particle.velocity[1] + vel_v - last_vel_v) * flipFac\n\n                    // Update particle position based on velocity\n                    particle.position[0] += particle.velocity[0] * dt\n                    particle.position[1] += particle.velocity[1] * dt\n\n                    this.insertParticleIntoHashTable(particle);\n                });\n            }\n\n          handle_collisions_and_boundary(dt) {\n                this.particles.forEach(particle => {\n                    // Update particle position based on velocity\n                    const x = particle.position[0];\n                    const y = particle.position[1];\n                    const r = particle.radius;\n\n                    // Handle boundary conditions\n                    if (x - r \u003C 0) {\n                        particle.velocity[0] *= 0;\n                        particle.position[0] = r;\n                    }\n                    if (x + r > BOUNDS[0]) {\n                        particle.velocity[0] *= 0;\n                        particle.position[0] = BOUNDS[0] - r;\n                    }\n                    if (y - r \u003C 0) {\n                        particle.velocity[1] *= 0;\n                        particle.position[1] = r;\n                    }\n                    if (y + r > BOUNDS[1]) {\n                        particle.velocity[1] *= 0;\n                        particle.position[1] = BOUNDS[1] - r;\n                    }\n\n                    var i = particle.position[0] / CELL_SIZE[0]\n                    var j = particle.position[1] / CELL_SIZE[1]\n\n\n                    // Push neighboring this.particles into the array\n                    var neighboringparticles = this.getparticlesFromHashTable(i, j);\n\n\n                    // Handle particle collisions\n                    neighboringparticles.forEach(other => {\n                        if (particle !== other) { // Ensure we're not checking the particle against itself\n\n                            var dx = other.position[0] - particle.position[0];\n                            var dy = other.position[1] - particle.position[1];\n                            const dist_squared = dx * dx + dy * dy;\n                            const min_dist_squared = (particle.radius + other.radius) ** 2;\n\n                            if (dist_squared \u003C min_dist_squared) {\n                                // Swap velocities\n                                const temp_velocity = particle.velocity.slice(); // Make a copy\n                                particle.velocity = other.velocity.slice();\n                                other.velocity = temp_velocity;\n\n                                // Calculate the direction of the collision\n                                const dist = Math.sqrt(dist_squared);\n                                const overlap = (particle.radius + other.radius) - dist;\n\n                                if (Math.abs(dist) > 0) {\n                                    dx /= dist\n                                    dy /= dist\n                                }\n\n                                // Move this.particles apart proportionally to their overlap\n                                const moveX = dx * overlap * 0.5;\n                                const moveY = dy * overlap * 0.5;\n\n                                // Move the this.particles in opposite directions\n                                particle.position[0] -= moveX;\n                                particle.position[1] -= moveY;\n                                \n                                other.position[0] += moveX;\n                                other.position[1] += moveY;\n                            }\n                        }\n                    });\n\n                    this.insertParticleIntoHashTable(particle);\n                });\n            }\n\n            insertParticleIntoHashTable(particle) {\n                var i = particle.position[0] / CELL_SIZE[0];\n                var j = particle.position[1] / CELL_SIZE[1];\n                const hash = this.hashCoords(i, j);\n\n                if (!this.particleHashTable[hash]) {\n                    this.particleHashTable[hash] = [];\n                }\n\n                this.particleHashTable[hash].push(particle);\n            }\n\n            getparticlesFromHashTable(i, j) {\n                i = Math.floor(i)\n                j = Math.floor(j)\n                const hash = this.hashCoords(i, j);\n                return this.particleHashTable[hash] || [];\n            }\n\n            hashCoords(i, j) {\n                i = Math.floor(i)\n                j = Math.floor(j)\n                var h = (i * 92837111) ^ (j * 689287499)\n                return Math.abs(h) % ((CELL_COUNT/4)**2)\n            }\n\n            clear() {\n                this.last_velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n                this.last_velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));\n                this.velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n                this.velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));\n                this.type = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n                this.pressure = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));\n            }\n\n            animate() {\n              this.update();\n              this.drawGrid();\n              requestAnimationFrame(this.animate);\n            }\n        }\n\n\n        lock = new Game();\n\n        document.getElementById('resetButton').addEventListener(\"click\", function(){lock.reset();})\n\n        document.addEventListener('DOMContentLoaded', function(){delete lock; lock = new Game(); lock.animate()});\n\n\u003C/script>\n\u003Ch3 id=\"conclusion\">Conclusion\u003C/h3>\n\u003Cp>There are a few limitations to the program. The first is the instability of the simulator.\nDue to errors in the divergence calculation, high values of overrelaxation, or too many\niterations can cause the fluid to behave strangely. As well as this, this.particles will pop at times\nin the simulation. Ideally, improving the divergence calculation and removing the this.pressure,\noverrelaxation, and iteration settings altogether would make the tool a lot easier to use.\u003C/p>\n\u003Cp>The second limitation is the time it takes to simulate the fluid. In further implementations,\nGPU support as well as a faster divergence calculation method would be included.\u003C/p>\n\u003Cp>The third limitation, which is more of a problem with Maya, was not being able to\nhave relative image paths. Although a set-project method could work, It can be quite limiting\nas users may need to set-project elsewhere depending on their scene. Therefore, at the present\nmoment, Maya Fluid Simulator does not have any icons or images associated with it.\u003C/p>\n\u003Cp>Other limitations are small issues that, with time, will be sorted as the code evolves.\nAlthough the program is already quite comprehensive, plans for the future would be\nto implement inflow objects, colliders, and a meshing solution so that the fluids could be used\nmore for real productions\u003C/p>\n\u003Cp>\u003Cem>Written May 10, 2024 by Christopher Hosken\u003C/em>\u003C/p>",{"headings":220,"imagePaths":248,"frontmatter":249},[221,222,225,226,229,232,235,238,241,244,247],{"depth":28,"slug":29,"text":30},{"depth":28,"slug":223,"text":224},"maya-fluid-simulator-report","Maya Fluid Simulator Report",{"depth":176,"slug":147,"text":148},{"depth":176,"slug":227,"text":228},"particle-to-grid-and-grid-to-particle","Particle to Grid and Grid to Particle",{"depth":176,"slug":230,"text":231},"finding-dt","Finding dt",{"depth":176,"slug":233,"text":234},"enforcing-boundaries-and-solving-divergence","Enforcing Boundaries and Solving Divergence",{"depth":176,"slug":236,"text":237},"particle-collisions","Particle Collisions",{"depth":176,"slug":239,"text":240},"pic-and-flip","PIC and FLIP",{"depth":176,"slug":242,"text":243},"results","Results",{"depth":176,"slug":245,"text":246},"js-simulator","JS Simulator",{"depth":176,"slug":72,"text":73},[],{"title":210,"date":211,"role":109,"excerpt":213,"img":212,"type":19},"mfs.md"]