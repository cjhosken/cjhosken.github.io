// src/index.ts
import path from "node:path";
import { fileURLToPath } from "node:url";
import { ZodError } from "zod";

// ../utils/src/logger.ts
var Logger = class {
  constructor(packageName2) {
    this.colors = {
      reset: "\x1B[0m",
      fg: {
        red: "\x1B[31m",
        green: "\x1B[32m",
        yellow: "\x1B[33m"
      }
    };
    this.packageName = packageName2;
  }
  log(msg, prefix = "") {
    const s = msg.join("\n");
    console.log(`%s${this.packageName}:%s ${s}
`, prefix, prefix ? this.colors.reset : "");
  }
  info(...msg) {
    this.log(msg);
  }
  success(...msg) {
    this.log(msg, this.colors.fg.green);
  }
  warn(...msg) {
    this.log(["Skipped!", ...msg], this.colors.fg.yellow);
  }
  error(...msg) {
    this.log(["Failed!", ...msg], this.colors.fg.red);
  }
};

// ../utils/src/error-helpers.ts
function getErrorMessage(err) {
  return err instanceof Error ? err.message : String(err);
}

// src/validate-options.ts
import { z as z2 } from "zod";

// src/schema.ts
import { z } from "zod";
import { EnumChangefreq as ChangeFreq } from "sitemap";

// src/config-defaults.ts
var SITEMAP_CONFIG_DEFAULTS = {
  createLinkInHead: true,
  entryLimit: 45e3,
  xmlns: {
    xhtml: true
  }
};

// src/schema.ts
var localeKeySchema = z.string().min(1);
var changefreqSchema = z.nativeEnum(ChangeFreq).optional();
var lastmodSchema = z.date().optional();
var prioritySchema = z.number().min(0).max(1).optional();
var SitemapOptionsSchema = z.object({
  canonicalURL: z.string().url().optional(),
  filter: z.function().args(z.string()).returns(z.boolean()).optional(),
  exclude: z.string().min(1).array().optional(),
  customPages: z.string().url().array().optional(),
  i18n: z.object({
    defaultLocale: localeKeySchema,
    locales: z.record(
      localeKeySchema,
      z.string().min(2).regex(/^[a-zA-Z\-]+$/gm, {
        message: "Only English alphabet symbols and hyphen allowed"
      })
    )
  }).refine((val) => !val || val.locales[val.defaultLocale], {
    message: "`defaultLocale` must exist in `locales` keys"
  }).optional(),
  entryLimit: z.number().nonnegative().optional().default(SITEMAP_CONFIG_DEFAULTS.entryLimit),
  lastmodDateOnly: z.boolean().optional().default(SITEMAP_CONFIG_DEFAULTS.xmlns.lastmodDateOnly),
  xslUrl: z.string().url().optional(),
  xmlns: z.object({
    xhtml: z.boolean().optional().default(SITEMAP_CONFIG_DEFAULTS.xmlns.xhtml),
    news: z.boolean().optional().default(SITEMAP_CONFIG_DEFAULTS.xmlns.news),
    image: z.boolean().optional().default(SITEMAP_CONFIG_DEFAULTS.xmlns.image),
    video: z.boolean().optional().default(SITEMAP_CONFIG_DEFAULTS.xmlns.video),
    custom: z.string().min(1).array().nonempty().optional()
  }).optional().default(SITEMAP_CONFIG_DEFAULTS.xmlns),
  serialize: z.function().args(z.any()).returns(z.any()).optional(),
  changefreq: changefreqSchema,
  lastmod: lastmodSchema,
  priority: prioritySchema,
  createLinkInHead: z.boolean().optional().default(SITEMAP_CONFIG_DEFAULTS.createLinkInHead)
}).strict().default(SITEMAP_CONFIG_DEFAULTS);

// src/validate-options.ts
var validateOptions = (site, opts) => {
  const result = SitemapOptionsSchema.parse(opts);
  z2.object({
    site: z2.string().optional(),
    // Astro takes care of `site`: how to validate, transform and refine it
    canonicalURL: z2.string().optional()
    // `canonicalURL` is already validated in prev step
  }).refine(({ site: site2, canonicalURL }) => site2 || canonicalURL, {
    message: "Required `site` astro.config option or `canonicalURL` integration option"
  }).parse({
    site,
    canonicalURL: result.canonicalURL
  });
  return result;
};

// src/helpers/parse-url.ts
var parseUrl = (url, defaultLocale, localeCodes, base) => {
  if (!url || !defaultLocale || localeCodes.length === 0 || localeCodes.some((key) => !key) || !base) {
    throw new Error("parseUrl: some parameters are empty");
  }
  if (url.indexOf(base) !== 0) {
    return void 0;
  }
  let s = url.replace(base, "");
  if (!s || s === "/") {
    return { locale: defaultLocale, path: "/" };
  }
  if (!s.startsWith("/")) {
    s = "/" + s;
  }
  const a = s.split("/");
  const locale = a[1];
  if (localeCodes.some((key) => key === locale)) {
    let path2 = a.slice(2).join("/");
    if (path2 === "//") {
      path2 = "/";
    }
    if (path2 !== "/" && !path2.startsWith("/")) {
      path2 = "/" + path2;
    }
    return { locale, path: path2 };
  }
  return { locale: defaultLocale, path: s };
};

// src/generate-sitemap.ts
var STATUS_CODE_PAGE_REGEXP = /\/[0-9]{3}\/?$/;
function generateSitemap(pages, finalSiteUrl, opts) {
  const { changefreq, priority, lastmod: lastmodSrc, i18n } = opts;
  const urls = [...pages].filter((url) => !STATUS_CODE_PAGE_REGEXP.test(url));
  urls.sort((a, b) => a.localeCompare(b, "en", { numeric: true }));
  const lastmod = lastmodSrc == null ? void 0 : lastmodSrc.toISOString();
  const { locales, defaultLocale } = i18n || {};
  const localeCodes = Object.keys(locales || {});
  const getPath = (url) => {
    const result = parseUrl(url, (i18n == null ? void 0 : i18n.defaultLocale) || "", localeCodes, finalSiteUrl);
    return result == null ? void 0 : result.path;
  };
  const getLocale = (url) => {
    const result = parseUrl(url, (i18n == null ? void 0 : i18n.defaultLocale) || "", localeCodes, finalSiteUrl);
    return result == null ? void 0 : result.locale;
  };
  const urlData = urls.map((url) => {
    let links;
    if (defaultLocale && locales) {
      const currentPath = getPath(url);
      if (currentPath) {
        const filtered = urls.filter((subUrl) => getPath(subUrl) === currentPath);
        if (filtered.length > 1) {
          links = filtered.map((subUrl) => ({
            url: subUrl,
            lang: locales[getLocale(subUrl)]
          }));
        }
      }
    }
    return {
      url,
      links,
      lastmod,
      priority,
      changefreq
    };
  });
  return urlData;
}

// src/sitemap/sitemap-simple-extended.ts
import { SitemapAndIndexStream, SitemapStream } from "sitemap";
import { createWriteStream, promises } from "node:fs";
import { normalize, resolve } from "node:path";
import { Readable, pipeline } from "node:stream";
import { createGzip } from "node:zlib";
import { format, promisify } from "node:util";
import { URL as URL2 } from "node:url";

// src/output-files.ts
var SITEMAP_INDEX_FILE_NAME = "sitemap-index.xml";
var SITEMAP_CHUNK_TEMPLATE = "sitemap-%d.xml";

// src/sitemap/sitemap-simple-extended.ts
var pipelineAsync = promisify(pipeline);
var simpleSitemapAndIndexExtended = async ({
  hostname,
  sitemapHostname = hostname,
  // if different
  /**
   * Pass a line separated list of sitemap items or a stream or an array
   */
  sourceData,
  destinationDir,
  limit = 45e3,
  publicBasePath = "./",
  lastmodDateOnly = false,
  xslUrl = void 0,
  xmlns,
  gzip = false
}) => {
  const result = [];
  const suffix = gzip ? ".gz" : "";
  await promises.mkdir(destinationDir, { recursive: true });
  const sitemapAndIndexStream = new SitemapAndIndexStream({
    limit,
    lastmodDateOnly,
    xslUrl,
    getSitemapStream(i) {
      const sitemapStream = new SitemapStream({
        hostname,
        lastmodDateOnly,
        xslUrl,
        xmlns
      });
      const chunkName = format(SITEMAP_CHUNK_TEMPLATE, i) + suffix;
      result.push(chunkName);
      const writePath2 = resolve(destinationDir, chunkName);
      if (!publicBasePath.endsWith("/")) {
        publicBasePath += "/";
      }
      const publicPath = normalize(publicBasePath + chunkName);
      let pipeline2;
      if (gzip) {
        pipeline2 = sitemapStream.pipe(createGzip()).pipe(createWriteStream(writePath2));
      } else {
        pipeline2 = sitemapStream.pipe(createWriteStream(writePath2));
      }
      return [new URL2(publicPath, sitemapHostname).toString(), sitemapStream, pipeline2];
    }
  });
  const src = Readable.from(sourceData);
  const indexName = SITEMAP_INDEX_FILE_NAME + suffix;
  const writePath = resolve(destinationDir, `./${indexName}`);
  if (gzip) {
    await pipelineAsync(src, sitemapAndIndexStream, createGzip(), createWriteStream(writePath));
  } else {
    await pipelineAsync(src, sitemapAndIndexStream, createWriteStream(writePath));
  }
  result.unshift(indexName);
  return result;
};

// src/process-pages.ts
import { promises as fs } from "node:fs";
var addTailSlash = (s) => s.endsWith("/") ? s : s + "/";
var removeHeadingSlash = (s) => s.replace(/^\/+/, "");
var removeTrailingSlash = (s) => s.replace(/\/+$/, "");
var getFileDir = (pathname) => {
  const name = addTailSlash(pathname);
  const file = name === "404/" ? "404.html" : `${name}index.html`;
  return removeHeadingSlash(file);
};
var getFileFile = (pathname) => pathname ? `${removeTrailingSlash(pathname)}.html` : "index.html";
async function processPages(pages, dir, headHTML, buildFormat, logger2) {
  if (buildFormat !== "directory" && buildFormat !== "file") {
    throw new Error(`Unsupported build.format: '${buildFormat}' in your astro.config`);
  }
  let insertedCount = 0;
  const HEAD_END_TAG = "</head>";
  for (const page of pages) {
    const fileUrl = new URL(buildFormat === "directory" ? getFileDir(page.pathname) : getFileFile(page.pathname), dir);
    const content = await fs.readFile(fileUrl, "utf-8");
    const index = content.indexOf(HEAD_END_TAG);
    if (index === -1) {
      logger2.info(`Cannot insert links. Reason: no <head> section in \`${fileUrl.pathname}\`.`);
    } else {
      const inlined = content.substring(0, index) + headHTML + content.substring(index);
      await fs.writeFile(fileUrl, inlined, "utf-8");
      insertedCount += 1;
    }
  }
  return insertedCount;
}

// src/helpers/exclude-routes.ts
import { minimatch } from "minimatch";
function excludeRoutes(patterns, routes) {
  patterns.forEach((pattern) => {
    const mm = new minimatch.Minimatch(pattern);
    mm.negate = true;
    routes = routes.filter((path2) => mm.match(path2));
  });
  return routes;
}

// src/data/pkg-name.ts
var packageName = "astro-sitemap";

// src/index.ts
import { EnumChangefreq } from "sitemap";
var logger = new Logger(packageName);
function formatConfigErrorMessage(err) {
  const errorList = err.issues.map((issue) => `${issue.path.join(".")}  ${issue.message + "."}`);
  return errorList.join("\n");
}
var createSitemapIntegration = (options = {}) => {
  let config;
  return {
    name: packageName,
    hooks: {
      "astro:config:done": async ({ config: cfg }) => {
        config = cfg;
      },
      "astro:build:done": async ({ dir, pages: srcPages }) => {
        try {
          const opts = validateOptions(config.site, options);
          const { filter, exclude, customPages, canonicalURL, entryLimit, lastmodDateOnly, xslUrl, xmlns, serialize, createLinkInHead } = opts;
          let finalSiteUrl;
          if (canonicalURL) {
            finalSiteUrl = new URL(canonicalURL);
            if (!finalSiteUrl.pathname.endsWith("/")) {
              finalSiteUrl.pathname += "/";
            }
          } else {
            finalSiteUrl = new URL(config.base, config.site);
          }
          let pages = srcPages.map(({ pathname }) => pathname);
          if (exclude == null ? void 0 : exclude.length) {
            try {
              pages = excludeRoutes(exclude, pages);
            } catch (err) {
              logger.error("Page exclusion error", getErrorMessage(err));
              return;
            }
          }
          if (filter) {
            try {
              pages = pages.filter(filter);
            } catch (err) {
              logger.error("Page filtering error", getErrorMessage(err));
              return;
            }
          }
          let pageUrls = pages.map((pathname) => {
            const path2 = finalSiteUrl.pathname + pathname;
            return new URL(path2, finalSiteUrl).href;
          });
          if (customPages) {
            pageUrls = [...pageUrls, ...customPages];
          }
          if (pageUrls.length === 0) {
            if (config.output !== "static") {
              logger.warn(
                "No pages found!",
                'We can only detect sitemap routes for "static" projects. Since you are using an SSR adapter, we recommend manually listing your sitemap routes using the "customPages" integration option.',
                "",
                "Example: `sitemap({ customPages: ['https://example.com/route'] })`"
              );
            } else {
              logger.warn("No pages found!");
            }
            return;
          }
          let urlData = generateSitemap(pageUrls, finalSiteUrl.href, opts);
          if (serialize) {
            try {
              const serializedUrls = [];
              for (const item of urlData) {
                const serialized = await Promise.resolve(serialize(item));
                if (serialized) {
                  serializedUrls.push(serialized);
                }
              }
              if (serializedUrls.length === 0) {
                logger.warn("No pages found!");
                return;
              }
              urlData = serializedUrls;
            } catch (err) {
              logger.error("Page serialization error", getErrorMessage(err));
              return;
            }
          }
          const fileNames = await simpleSitemapAndIndexExtended({
            hostname: finalSiteUrl.href,
            destinationDir: fileURLToPath(dir),
            sourceData: urlData,
            limit: entryLimit,
            lastmodDateOnly,
            xslUrl,
            xmlns
          });
          logger.success(`${fileNames.map((name) => `\`${name}\``).join(", ")} are created.`, `Total entries: ${urlData.length}.`);
          if (createLinkInHead && srcPages.length > 0) {
            const sitemapHref = path.posix.join(config.base, fileNames[0]);
            const headHTML = `<link rel="sitemap" type="application/xml" href="${sitemapHref}">`;
            const insertedCount = await processPages(srcPages, dir, headHTML, config.build.format, logger);
            if (insertedCount > 0) {
              logger.success(`Sitemap links are inserted into <head> section of generated pages (${insertedCount} of ${srcPages.length}).`);
            }
          }
        } catch (err) {
          if (err instanceof ZodError) {
            logger.warn(formatConfigErrorMessage(err));
          } else {
            throw err;
          }
        }
      }
    }
  };
};
var src_default = createSitemapIntegration;
export {
  EnumChangefreq,
  src_default as default
};
